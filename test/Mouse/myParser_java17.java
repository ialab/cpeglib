//=========================================================================
//
//  This file was generated by Mouse 1.9 at 2017-06-21 10:09:31 GMT
//  from grammar '/Users/yuta/code/github/cpeg/test/Mouse/./Java.1.7.peg'.
//
//=========================================================================

import mouse.runtime.Source;

public class myParser_java17 extends mouse.runtime.ParserBase
{
  final mouse.runtime.SemanticsBase sem;
  
  //=======================================================================
  //
  //  Initialization
  //
  //=======================================================================
  //-------------------------------------------------------------------
  //  Constructor
  //-------------------------------------------------------------------
  public myParser_java17()
    {
      sem = new mouse.runtime.SemanticsBase();
      sem.rule = this;
      super.sem = sem;
    }
  
  //-------------------------------------------------------------------
  //  Run the parser
  //-------------------------------------------------------------------
  public boolean parse(Source src)
    {
      super.init(src);
      sem.init();
      boolean result = CompilationUnit();
      closeParser(result);
      return result;
    }
  
  //-------------------------------------------------------------------
  //  Get semantics
  //-------------------------------------------------------------------
  public mouse.runtime.SemanticsBase semantics()
    { return sem; }
  
  //=======================================================================
  //
  //  Parsing procedures
  //
  //=======================================================================
  //=====================================================================
  //  CompilationUnit = Spacing PackageDeclaration? ImportDeclaration*
  //    TypeDeclaration* EOT ;
  //=====================================================================
  private boolean CompilationUnit()
    {
      begin("CompilationUnit");
      Spacing();
      PackageDeclaration();
      while (ImportDeclaration());
      while (TypeDeclaration());
      if (!EOT()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  PackageDeclaration = Annotation* PACKAGE QualifiedIdentifier SEMI
  //    ;
  //=====================================================================
  private boolean PackageDeclaration()
    {
      begin("PackageDeclaration");
      while (Annotation());
      if (!PACKAGE()) return reject();
      if (!QualifiedIdentifier()) return reject();
      if (!SEMI()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ImportDeclaration = IMPORT STATIC? QualifiedIdentifier (DOT STAR)?
  //    SEMI / SEMI ;
  //=====================================================================
  private boolean ImportDeclaration()
    {
      begin("ImportDeclaration");
      if (ImportDeclaration_0()) return accept();
      if (SEMI()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  ImportDeclaration_0 = IMPORT STATIC? QualifiedIdentifier (DOT
  //    STAR)? SEMI
  //-------------------------------------------------------------------
  private boolean ImportDeclaration_0()
    {
      begin("");
      if (!IMPORT()) return rejectInner();
      STATIC();
      if (!QualifiedIdentifier()) return rejectInner();
      ImportDeclaration_1();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  ImportDeclaration_1 = DOT STAR
  //-------------------------------------------------------------------
  private boolean ImportDeclaration_1()
    {
      begin("");
      if (!DOT()) return rejectInner();
      if (!STAR()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  TypeDeclaration = Modifier* (ClassDeclaration / EnumDeclaration /
  //    InterfaceDeclaration / AnnotationTypeDeclaration) / SEMI ;
  //=====================================================================
  private boolean TypeDeclaration()
    {
      begin("TypeDeclaration");
      if (TypeDeclaration_0()) return accept();
      if (SEMI()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  TypeDeclaration_0 = Modifier* (ClassDeclaration / EnumDeclaration
  //    / InterfaceDeclaration / AnnotationTypeDeclaration)
  //-------------------------------------------------------------------
  private boolean TypeDeclaration_0()
    {
      begin("");
      while (Modifier());
      if (!ClassDeclaration()
       && !EnumDeclaration()
       && !InterfaceDeclaration()
       && !AnnotationTypeDeclaration()
         ) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ClassDeclaration = CLASS Identifier TypeParameters? (EXTENDS
  //    ClassType)? (IMPLEMENTS ClassTypeList)? ClassBody ;
  //=====================================================================
  private boolean ClassDeclaration()
    {
      begin("ClassDeclaration");
      if (!CLASS()) return reject();
      if (!Identifier()) return reject();
      TypeParameters();
      ClassDeclaration_0();
      ClassDeclaration_1();
      if (!ClassBody()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ClassDeclaration_0 = EXTENDS ClassType
  //-------------------------------------------------------------------
  private boolean ClassDeclaration_0()
    {
      begin("");
      if (!EXTENDS()) return rejectInner();
      if (!ClassType()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  ClassDeclaration_1 = IMPLEMENTS ClassTypeList
  //-------------------------------------------------------------------
  private boolean ClassDeclaration_1()
    {
      begin("");
      if (!IMPLEMENTS()) return rejectInner();
      if (!ClassTypeList()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ClassBody = LWING ClassBodyDeclaration* RWING ;
  //=====================================================================
  private boolean ClassBody()
    {
      begin("ClassBody");
      if (!LWING()) return reject();
      while (ClassBodyDeclaration());
      if (!RWING()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ClassBodyDeclaration = SEMI / STATIC? Block / Modifier* MemberDecl
  //    ;
  //=====================================================================
  private boolean ClassBodyDeclaration()
    {
      begin("ClassBodyDeclaration");
      if (SEMI()) return accept();
      if (ClassBodyDeclaration_0()) return accept();
      if (ClassBodyDeclaration_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  ClassBodyDeclaration_0 = STATIC? Block
  //-------------------------------------------------------------------
  private boolean ClassBodyDeclaration_0()
    {
      begin("");
      STATIC();
      if (!Block()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  ClassBodyDeclaration_1 = Modifier* MemberDecl
  //-------------------------------------------------------------------
  private boolean ClassBodyDeclaration_1()
    {
      begin("");
      while (Modifier());
      if (!MemberDecl()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  MemberDecl = TypeParameters GenericMethodOrConstructorRest / Type
  //    Identifier MethodDeclaratorRest / Type VariableDeclarators SEMI /
  //    VOID Identifier VoidMethodDeclaratorRest / Identifier
  //    ConstructorDeclaratorRest / InterfaceDeclaration /
  //    ClassDeclaration / EnumDeclaration / AnnotationTypeDeclaration ;
  //=====================================================================
  private boolean MemberDecl()
    {
      begin("MemberDecl");
      if (MemberDecl_0()) return accept();
      if (MemberDecl_1()) return accept();
      if (MemberDecl_2()) return accept();
      if (MemberDecl_3()) return accept();
      if (MemberDecl_4()) return accept();
      if (InterfaceDeclaration()) return accept();
      if (ClassDeclaration()) return accept();
      if (EnumDeclaration()) return accept();
      if (AnnotationTypeDeclaration()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  MemberDecl_0 = TypeParameters GenericMethodOrConstructorRest
  //-------------------------------------------------------------------
  private boolean MemberDecl_0()
    {
      begin("");
      if (!TypeParameters()) return rejectInner();
      if (!GenericMethodOrConstructorRest()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  MemberDecl_1 = Type Identifier MethodDeclaratorRest
  //-------------------------------------------------------------------
  private boolean MemberDecl_1()
    {
      begin("");
      if (!Type()) return rejectInner();
      if (!Identifier()) return rejectInner();
      if (!MethodDeclaratorRest()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  MemberDecl_2 = Type VariableDeclarators SEMI
  //-------------------------------------------------------------------
  private boolean MemberDecl_2()
    {
      begin("");
      if (!Type()) return rejectInner();
      if (!VariableDeclarators()) return rejectInner();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  MemberDecl_3 = VOID Identifier VoidMethodDeclaratorRest
  //-------------------------------------------------------------------
  private boolean MemberDecl_3()
    {
      begin("");
      if (!VOID()) return rejectInner();
      if (!Identifier()) return rejectInner();
      if (!VoidMethodDeclaratorRest()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  MemberDecl_4 = Identifier ConstructorDeclaratorRest
  //-------------------------------------------------------------------
  private boolean MemberDecl_4()
    {
      begin("");
      if (!Identifier()) return rejectInner();
      if (!ConstructorDeclaratorRest()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  GenericMethodOrConstructorRest = (Type / VOID) Identifier
  //    MethodDeclaratorRest / Identifier ConstructorDeclaratorRest ;
  //=====================================================================
  private boolean GenericMethodOrConstructorRest()
    {
      begin("GenericMethodOrConstructorRest");
      if (GenericMethodOrConstructorRest_0()) return accept();
      if (MemberDecl_4()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  GenericMethodOrConstructorRest_0 = (Type / VOID) Identifier
  //    MethodDeclaratorRest
  //-------------------------------------------------------------------
  private boolean GenericMethodOrConstructorRest_0()
    {
      begin("");
      if (!Type()
       && !VOID()
         ) return rejectInner();
      if (!Identifier()) return rejectInner();
      if (!MethodDeclaratorRest()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  MethodDeclaratorRest = FormalParameters Dim* (THROWS
  //    ClassTypeList)? (MethodBody / SEMI) ;
  //=====================================================================
  private boolean MethodDeclaratorRest()
    {
      begin("MethodDeclaratorRest");
      if (!FormalParameters()) return reject();
      while (Dim());
      MethodDeclaratorRest_0();
      if (!MethodBody()
       && !SEMI()
         ) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  MethodDeclaratorRest_0 = THROWS ClassTypeList
  //-------------------------------------------------------------------
  private boolean MethodDeclaratorRest_0()
    {
      begin("");
      if (!THROWS()) return rejectInner();
      if (!ClassTypeList()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  VoidMethodDeclaratorRest = FormalParameters (THROWS ClassTypeList)?
  //    (MethodBody / SEMI) ;
  //=====================================================================
  private boolean VoidMethodDeclaratorRest()
    {
      begin("VoidMethodDeclaratorRest");
      if (!FormalParameters()) return reject();
      MethodDeclaratorRest_0();
      if (!MethodBody()
       && !SEMI()
         ) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ConstructorDeclaratorRest = FormalParameters (THROWS
  //    ClassTypeList)? MethodBody ;
  //=====================================================================
  private boolean ConstructorDeclaratorRest()
    {
      begin("ConstructorDeclaratorRest");
      if (!FormalParameters()) return reject();
      MethodDeclaratorRest_0();
      if (!MethodBody()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  MethodBody = Block ;
  //=====================================================================
  private boolean MethodBody()
    {
      begin("MethodBody");
      if (!Block()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  InterfaceDeclaration = INTERFACE Identifier TypeParameters?
  //    (EXTENDS ClassTypeList)? InterfaceBody ;
  //=====================================================================
  private boolean InterfaceDeclaration()
    {
      begin("InterfaceDeclaration");
      if (!INTERFACE()) return reject();
      if (!Identifier()) return reject();
      TypeParameters();
      InterfaceDeclaration_0();
      if (!InterfaceBody()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  InterfaceDeclaration_0 = EXTENDS ClassTypeList
  //-------------------------------------------------------------------
  private boolean InterfaceDeclaration_0()
    {
      begin("");
      if (!EXTENDS()) return rejectInner();
      if (!ClassTypeList()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  InterfaceBody = LWING InterfaceBodyDeclaration* RWING ;
  //=====================================================================
  private boolean InterfaceBody()
    {
      begin("InterfaceBody");
      if (!LWING()) return reject();
      while (InterfaceBodyDeclaration());
      if (!RWING()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  InterfaceBodyDeclaration = Modifier* InterfaceMemberDecl / SEMI ;
  //=====================================================================
  private boolean InterfaceBodyDeclaration()
    {
      begin("InterfaceBodyDeclaration");
      if (InterfaceBodyDeclaration_0()) return accept();
      if (SEMI()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  InterfaceBodyDeclaration_0 = Modifier* InterfaceMemberDecl
  //-------------------------------------------------------------------
  private boolean InterfaceBodyDeclaration_0()
    {
      begin("");
      while (Modifier());
      if (!InterfaceMemberDecl()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  InterfaceMemberDecl = InterfaceMethodOrFieldDecl /
  //    InterfaceGenericMethodDecl / VOID Identifier
  //    VoidInterfaceMethodDeclaratorRest / InterfaceDeclaration /
  //    AnnotationTypeDeclaration / ClassDeclaration / EnumDeclaration ;
  //=====================================================================
  private boolean InterfaceMemberDecl()
    {
      begin("InterfaceMemberDecl");
      if (InterfaceMethodOrFieldDecl()) return accept();
      if (InterfaceGenericMethodDecl()) return accept();
      if (InterfaceMemberDecl_0()) return accept();
      if (InterfaceDeclaration()) return accept();
      if (AnnotationTypeDeclaration()) return accept();
      if (ClassDeclaration()) return accept();
      if (EnumDeclaration()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  InterfaceMemberDecl_0 = VOID Identifier
  //    VoidInterfaceMethodDeclaratorRest
  //-------------------------------------------------------------------
  private boolean InterfaceMemberDecl_0()
    {
      begin("");
      if (!VOID()) return rejectInner();
      if (!Identifier()) return rejectInner();
      if (!VoidInterfaceMethodDeclaratorRest()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  InterfaceMethodOrFieldDecl = Type Identifier
  //    InterfaceMethodOrFieldRest ;
  //=====================================================================
  private boolean InterfaceMethodOrFieldDecl()
    {
      begin("InterfaceMethodOrFieldDecl");
      if (!Type()) return reject();
      if (!Identifier()) return reject();
      if (!InterfaceMethodOrFieldRest()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  InterfaceMethodOrFieldRest = ConstantDeclaratorsRest SEMI /
  //    InterfaceMethodDeclaratorRest ;
  //=====================================================================
  private boolean InterfaceMethodOrFieldRest()
    {
      begin("InterfaceMethodOrFieldRest");
      if (InterfaceMethodOrFieldRest_0()) return accept();
      if (InterfaceMethodDeclaratorRest()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  InterfaceMethodOrFieldRest_0 = ConstantDeclaratorsRest SEMI
  //-------------------------------------------------------------------
  private boolean InterfaceMethodOrFieldRest_0()
    {
      begin("");
      if (!ConstantDeclaratorsRest()) return rejectInner();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  InterfaceMethodDeclaratorRest = FormalParameters Dim* (THROWS
  //    ClassTypeList)? SEMI ;
  //=====================================================================
  private boolean InterfaceMethodDeclaratorRest()
    {
      begin("InterfaceMethodDeclaratorRest");
      if (!FormalParameters()) return reject();
      while (Dim());
      MethodDeclaratorRest_0();
      if (!SEMI()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  InterfaceGenericMethodDecl = TypeParameters (Type / VOID)
  //    Identifier InterfaceMethodDeclaratorRest ;
  //=====================================================================
  private boolean InterfaceGenericMethodDecl()
    {
      begin("InterfaceGenericMethodDecl");
      if (!TypeParameters()) return reject();
      if (!Type()
       && !VOID()
         ) return reject();
      if (!Identifier()) return reject();
      if (!InterfaceMethodDeclaratorRest()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  VoidInterfaceMethodDeclaratorRest = FormalParameters (THROWS
  //    ClassTypeList)? SEMI ;
  //=====================================================================
  private boolean VoidInterfaceMethodDeclaratorRest()
    {
      begin("VoidInterfaceMethodDeclaratorRest");
      if (!FormalParameters()) return reject();
      MethodDeclaratorRest_0();
      if (!SEMI()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ConstantDeclaratorsRest = ConstantDeclaratorRest (COMMA
  //    ConstantDeclarator)* ;
  //=====================================================================
  private boolean ConstantDeclaratorsRest()
    {
      begin("ConstantDeclaratorsRest");
      if (!ConstantDeclaratorRest()) return reject();
      while (ConstantDeclaratorsRest_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ConstantDeclaratorsRest_0 = COMMA ConstantDeclarator
  //-------------------------------------------------------------------
  private boolean ConstantDeclaratorsRest_0()
    {
      begin("");
      if (!COMMA()) return rejectInner();
      if (!ConstantDeclarator()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ConstantDeclarator = Identifier ConstantDeclaratorRest ;
  //=====================================================================
  private boolean ConstantDeclarator()
    {
      begin("ConstantDeclarator");
      if (!Identifier()) return reject();
      if (!ConstantDeclaratorRest()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ConstantDeclaratorRest = Dim* EQU VariableInitializer ;
  //=====================================================================
  private boolean ConstantDeclaratorRest()
    {
      begin("ConstantDeclaratorRest");
      while (Dim());
      if (!EQU()) return reject();
      if (!VariableInitializer()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  EnumDeclaration = ENUM Identifier (IMPLEMENTS ClassTypeList)?
  //    EnumBody ;
  //=====================================================================
  private boolean EnumDeclaration()
    {
      begin("EnumDeclaration");
      if (!ENUM()) return reject();
      if (!Identifier()) return reject();
      ClassDeclaration_1();
      if (!EnumBody()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  EnumBody = LWING EnumConstants? COMMA? EnumBodyDeclarations? RWING
  //    ;
  //=====================================================================
  private boolean EnumBody()
    {
      begin("EnumBody");
      if (!LWING()) return reject();
      EnumConstants();
      COMMA();
      EnumBodyDeclarations();
      if (!RWING()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  EnumConstants = EnumConstant (COMMA EnumConstant)* ;
  //=====================================================================
  private boolean EnumConstants()
    {
      begin("EnumConstants");
      if (!EnumConstant()) return reject();
      while (EnumConstants_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  EnumConstants_0 = COMMA EnumConstant
  //-------------------------------------------------------------------
  private boolean EnumConstants_0()
    {
      begin("");
      if (!COMMA()) return rejectInner();
      if (!EnumConstant()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  EnumConstant = Annotation* Identifier Arguments? ClassBody? ;
  //=====================================================================
  private boolean EnumConstant()
    {
      begin("EnumConstant");
      while (Annotation());
      if (!Identifier()) return reject();
      Arguments();
      ClassBody();
      return accept();
    }
  
  //=====================================================================
  //  EnumBodyDeclarations = SEMI ClassBodyDeclaration* ;
  //=====================================================================
  private boolean EnumBodyDeclarations()
    {
      begin("EnumBodyDeclarations");
      if (!SEMI()) return reject();
      while (ClassBodyDeclaration());
      return accept();
    }
  
  //=====================================================================
  //  LocalVariableDeclarationStatement = (FINAL / Annotation)* Type
  //    VariableDeclarators SEMI ;
  //=====================================================================
  private boolean LocalVariableDeclarationStatement()
    {
      begin("LocalVariableDeclarationStatement");
      while (LocalVariableDeclarationStatement_0());
      if (!Type()) return reject();
      if (!VariableDeclarators()) return reject();
      if (!SEMI()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  LocalVariableDeclarationStatement_0 = FINAL / Annotation
  //-------------------------------------------------------------------
  private boolean LocalVariableDeclarationStatement_0()
    {
      begin("");
      if (FINAL()) return acceptInner();
      if (Annotation()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  VariableDeclarators = VariableDeclarator (COMMA
  //    VariableDeclarator)* ;
  //=====================================================================
  private boolean VariableDeclarators()
    {
      begin("VariableDeclarators");
      if (!VariableDeclarator()) return reject();
      while (VariableDeclarators_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  VariableDeclarators_0 = COMMA VariableDeclarator
  //-------------------------------------------------------------------
  private boolean VariableDeclarators_0()
    {
      begin("");
      if (!COMMA()) return rejectInner();
      if (!VariableDeclarator()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  VariableDeclarator = Identifier Dim* (EQU VariableInitializer)? ;
  //=====================================================================
  private boolean VariableDeclarator()
    {
      begin("VariableDeclarator");
      if (!Identifier()) return reject();
      while (Dim());
      VariableDeclarator_0();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  VariableDeclarator_0 = EQU VariableInitializer
  //-------------------------------------------------------------------
  private boolean VariableDeclarator_0()
    {
      begin("");
      if (!EQU()) return rejectInner();
      if (!VariableInitializer()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  FormalParameters = LPAR FormalParameterList? RPAR ;
  //=====================================================================
  private boolean FormalParameters()
    {
      begin("FormalParameters");
      if (!LPAR()) return reject();
      FormalParameterList();
      if (!RPAR()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  FormalParameter = (FINAL / Annotation)* Type VariableDeclaratorId
  //    ;
  //=====================================================================
  private boolean FormalParameter()
    {
      begin("FormalParameter");
      while (LocalVariableDeclarationStatement_0());
      if (!Type()) return reject();
      if (!VariableDeclaratorId()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  LastFormalParameter = (FINAL / Annotation)* Type ELLIPSIS
  //    VariableDeclaratorId ;
  //=====================================================================
  private boolean LastFormalParameter()
    {
      begin("LastFormalParameter");
      while (LocalVariableDeclarationStatement_0());
      if (!Type()) return reject();
      if (!ELLIPSIS()) return reject();
      if (!VariableDeclaratorId()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  FormalParameterList = FormalParameter (COMMA FormalParameter)*
  //    (COMMA LastFormalParameter)? / LastFormalParameter ;
  //=====================================================================
  private boolean FormalParameterList()
    {
      begin("FormalParameterList");
      if (FormalParameterList_0()) return accept();
      if (LastFormalParameter()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  FormalParameterList_0 = FormalParameter (COMMA FormalParameter)*
  //    (COMMA LastFormalParameter)?
  //-------------------------------------------------------------------
  private boolean FormalParameterList_0()
    {
      begin("");
      if (!FormalParameter()) return rejectInner();
      while (FormalParameterList_1());
      FormalParameterList_2();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  FormalParameterList_1 = COMMA FormalParameter
  //-------------------------------------------------------------------
  private boolean FormalParameterList_1()
    {
      begin("");
      if (!COMMA()) return rejectInner();
      if (!FormalParameter()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  FormalParameterList_2 = COMMA LastFormalParameter
  //-------------------------------------------------------------------
  private boolean FormalParameterList_2()
    {
      begin("");
      if (!COMMA()) return rejectInner();
      if (!LastFormalParameter()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  VariableDeclaratorId = Identifier Dim* ;
  //=====================================================================
  private boolean VariableDeclaratorId()
    {
      begin("VariableDeclaratorId");
      if (!Identifier()) return reject();
      while (Dim());
      return accept();
    }
  
  //=====================================================================
  //  Block = LWING BlockStatements RWING ;
  //=====================================================================
  private boolean Block()
    {
      begin("Block");
      if (!LWING()) return reject();
      BlockStatements();
      if (!RWING()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  BlockStatements = BlockStatement* ;
  //=====================================================================
  private boolean BlockStatements()
    {
      begin("BlockStatements");
      while (BlockStatement());
      return accept();
    }
  
  //=====================================================================
  //  BlockStatement = LocalVariableDeclarationStatement / Modifier*
  //    (ClassDeclaration / EnumDeclaration) / Statement ;
  //=====================================================================
  private boolean BlockStatement()
    {
      begin("BlockStatement");
      if (LocalVariableDeclarationStatement()) return accept();
      if (BlockStatement_0()) return accept();
      if (Statement()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  BlockStatement_0 = Modifier* (ClassDeclaration /
  //    EnumDeclaration)
  //-------------------------------------------------------------------
  private boolean BlockStatement_0()
    {
      begin("");
      while (Modifier());
      if (!ClassDeclaration()
       && !EnumDeclaration()
         ) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Statement = Block / ASSERT Expression (COLON Expression)? SEMI / IF
  //    ParExpression Statement (ELSE Statement)? / FOR LPAR ForInit?
  //    SEMI Expression? SEMI ForUpdate? RPAR Statement / FOR LPAR
  //    FormalParameter COLON Expression RPAR Statement / WHILE
  //    ParExpression Statement / DO Statement WHILE ParExpression SEMI /
  //    TRY LPAR Resource (SEMI Resource)* SEMI? RPAR Block Catch*
  //    Finally? / TRY Block (Catch+ Finally? / Finally) / SWITCH
  //    ParExpression LWING SwitchBlockStatementGroups RWING /
  //    SYNCHRONIZED ParExpression Block / RETURN Expression? SEMI /
  //    THROW Expression SEMI / BREAK Identifier? SEMI / CONTINUE
  //    Identifier? SEMI / SEMI / StatementExpression SEMI / Identifier
  //    COLON Statement ;
  //=====================================================================
  private boolean Statement()
    {
      begin("Statement");
      if (Block()) return accept();
      if (Statement_0()) return accept();
      if (Statement_1()) return accept();
      if (Statement_2()) return accept();
      if (Statement_3()) return accept();
      if (Statement_4()) return accept();
      if (Statement_5()) return accept();
      if (Statement_6()) return accept();
      if (Statement_7()) return accept();
      if (Statement_8()) return accept();
      if (Statement_9()) return accept();
      if (Statement_10()) return accept();
      if (Statement_11()) return accept();
      if (Statement_12()) return accept();
      if (Statement_13()) return accept();
      if (SEMI()) return accept();
      if (Statement_14()) return accept();
      if (Statement_15()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  Statement_0 = ASSERT Expression (COLON Expression)? SEMI
  //-------------------------------------------------------------------
  private boolean Statement_0()
    {
      begin("");
      if (!ASSERT()) return rejectInner();
      if (!Expression()) return rejectInner();
      Statement_16();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_1 = IF ParExpression Statement (ELSE Statement)?
  //-------------------------------------------------------------------
  private boolean Statement_1()
    {
      begin("");
      if (!IF()) return rejectInner();
      if (!ParExpression()) return rejectInner();
      if (!Statement()) return rejectInner();
      Statement_17();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_2 = FOR LPAR ForInit? SEMI Expression? SEMI ForUpdate?
  //    RPAR Statement
  //-------------------------------------------------------------------
  private boolean Statement_2()
    {
      begin("");
      if (!FOR()) return rejectInner();
      if (!LPAR()) return rejectInner();
      ForInit();
      if (!SEMI()) return rejectInner();
      Expression();
      if (!SEMI()) return rejectInner();
      ForUpdate();
      if (!RPAR()) return rejectInner();
      if (!Statement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_3 = FOR LPAR FormalParameter COLON Expression RPAR
  //    Statement
  //-------------------------------------------------------------------
  private boolean Statement_3()
    {
      begin("");
      if (!FOR()) return rejectInner();
      if (!LPAR()) return rejectInner();
      if (!FormalParameter()) return rejectInner();
      if (!COLON()) return rejectInner();
      if (!Expression()) return rejectInner();
      if (!RPAR()) return rejectInner();
      if (!Statement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_4 = WHILE ParExpression Statement
  //-------------------------------------------------------------------
  private boolean Statement_4()
    {
      begin("");
      if (!WHILE()) return rejectInner();
      if (!ParExpression()) return rejectInner();
      if (!Statement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_5 = DO Statement WHILE ParExpression SEMI
  //-------------------------------------------------------------------
  private boolean Statement_5()
    {
      begin("");
      if (!DO()) return rejectInner();
      if (!Statement()) return rejectInner();
      if (!WHILE()) return rejectInner();
      if (!ParExpression()) return rejectInner();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_6 = TRY LPAR Resource (SEMI Resource)* SEMI? RPAR Block
  //    Catch* Finally?
  //-------------------------------------------------------------------
  private boolean Statement_6()
    {
      begin("");
      if (!TRY()) return rejectInner();
      if (!LPAR()) return rejectInner();
      if (!Resource()) return rejectInner();
      while (Statement_18());
      SEMI();
      if (!RPAR()) return rejectInner();
      if (!Block()) return rejectInner();
      while (Catch());
      Finally();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_7 = TRY Block (Catch+ Finally? / Finally)
  //-------------------------------------------------------------------
  private boolean Statement_7()
    {
      begin("");
      if (!TRY()) return rejectInner();
      if (!Block()) return rejectInner();
      if (!Statement_19()
       && !Finally()
         ) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_8 = SWITCH ParExpression LWING
  //    SwitchBlockStatementGroups RWING
  //-------------------------------------------------------------------
  private boolean Statement_8()
    {
      begin("");
      if (!SWITCH()) return rejectInner();
      if (!ParExpression()) return rejectInner();
      if (!LWING()) return rejectInner();
      SwitchBlockStatementGroups();
      if (!RWING()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_9 = SYNCHRONIZED ParExpression Block
  //-------------------------------------------------------------------
  private boolean Statement_9()
    {
      begin("");
      if (!SYNCHRONIZED()) return rejectInner();
      if (!ParExpression()) return rejectInner();
      if (!Block()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_10 = RETURN Expression? SEMI
  //-------------------------------------------------------------------
  private boolean Statement_10()
    {
      begin("");
      if (!RETURN()) return rejectInner();
      Expression();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_11 = THROW Expression SEMI
  //-------------------------------------------------------------------
  private boolean Statement_11()
    {
      begin("");
      if (!THROW()) return rejectInner();
      if (!Expression()) return rejectInner();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_12 = BREAK Identifier? SEMI
  //-------------------------------------------------------------------
  private boolean Statement_12()
    {
      begin("");
      if (!BREAK()) return rejectInner();
      Identifier();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_13 = CONTINUE Identifier? SEMI
  //-------------------------------------------------------------------
  private boolean Statement_13()
    {
      begin("");
      if (!CONTINUE()) return rejectInner();
      Identifier();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_14 = StatementExpression SEMI
  //-------------------------------------------------------------------
  private boolean Statement_14()
    {
      begin("");
      if (!StatementExpression()) return rejectInner();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_15 = Identifier COLON Statement
  //-------------------------------------------------------------------
  private boolean Statement_15()
    {
      begin("");
      if (!Identifier()) return rejectInner();
      if (!COLON()) return rejectInner();
      if (!Statement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_16 = COLON Expression
  //-------------------------------------------------------------------
  private boolean Statement_16()
    {
      begin("");
      if (!COLON()) return rejectInner();
      if (!Expression()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_17 = ELSE Statement
  //-------------------------------------------------------------------
  private boolean Statement_17()
    {
      begin("");
      if (!ELSE()) return rejectInner();
      if (!Statement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_18 = SEMI Resource
  //-------------------------------------------------------------------
  private boolean Statement_18()
    {
      begin("");
      if (!SEMI()) return rejectInner();
      if (!Resource()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_19 = Catch+ Finally?
  //-------------------------------------------------------------------
  private boolean Statement_19()
    {
      begin("");
      if (!Catch()) return rejectInner();
      while (Catch());
      Finally();
      return acceptInner();
    }
  
  //=====================================================================
  //  Resource = (FINAL / Annotation)* Type VariableDeclaratorId EQU
  //    Expression ;
  //=====================================================================
  private boolean Resource()
    {
      begin("Resource");
      while (LocalVariableDeclarationStatement_0());
      if (!Type()) return reject();
      if (!VariableDeclaratorId()) return reject();
      if (!EQU()) return reject();
      if (!Expression()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Catch = CATCH LPAR (FINAL / Annotation)* Type (OR Type)*
  //    VariableDeclaratorId RPAR Block ;
  //=====================================================================
  private boolean Catch()
    {
      begin("Catch");
      if (!CATCH()) return reject();
      if (!LPAR()) return reject();
      while (LocalVariableDeclarationStatement_0());
      if (!Type()) return reject();
      while (Catch_0());
      if (!VariableDeclaratorId()) return reject();
      if (!RPAR()) return reject();
      if (!Block()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Catch_0 = OR Type
  //-------------------------------------------------------------------
  private boolean Catch_0()
    {
      begin("");
      if (!OR()) return rejectInner();
      if (!Type()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Finally = FINALLY Block ;
  //=====================================================================
  private boolean Finally()
    {
      begin("Finally");
      if (!FINALLY()) return reject();
      if (!Block()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  SwitchBlockStatementGroups = SwitchBlockStatementGroup* ;
  //=====================================================================
  private boolean SwitchBlockStatementGroups()
    {
      begin("SwitchBlockStatementGroups");
      while (SwitchBlockStatementGroup());
      return accept();
    }
  
  //=====================================================================
  //  SwitchBlockStatementGroup = SwitchLabel BlockStatements ;
  //=====================================================================
  private boolean SwitchBlockStatementGroup()
    {
      begin("SwitchBlockStatementGroup");
      if (!SwitchLabel()) return reject();
      BlockStatements();
      return accept();
    }
  
  //=====================================================================
  //  SwitchLabel = CASE ConstantExpression COLON / CASE EnumConstantName
  //    COLON / DEFAULT COLON ;
  //=====================================================================
  private boolean SwitchLabel()
    {
      begin("SwitchLabel");
      if (SwitchLabel_0()) return accept();
      if (SwitchLabel_1()) return accept();
      if (SwitchLabel_2()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  SwitchLabel_0 = CASE ConstantExpression COLON
  //-------------------------------------------------------------------
  private boolean SwitchLabel_0()
    {
      begin("");
      if (!CASE()) return rejectInner();
      if (!ConstantExpression()) return rejectInner();
      if (!COLON()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  SwitchLabel_1 = CASE EnumConstantName COLON
  //-------------------------------------------------------------------
  private boolean SwitchLabel_1()
    {
      begin("");
      if (!CASE()) return rejectInner();
      if (!EnumConstantName()) return rejectInner();
      if (!COLON()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  SwitchLabel_2 = DEFAULT COLON
  //-------------------------------------------------------------------
  private boolean SwitchLabel_2()
    {
      begin("");
      if (!DEFAULT()) return rejectInner();
      if (!COLON()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ForInit = (FINAL / Annotation)* Type VariableDeclarators /
  //    StatementExpression (COMMA StatementExpression)* ;
  //=====================================================================
  private boolean ForInit()
    {
      begin("ForInit");
      if (ForInit_0()) return accept();
      if (ForInit_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  ForInit_0 = (FINAL / Annotation)* Type VariableDeclarators
  //-------------------------------------------------------------------
  private boolean ForInit_0()
    {
      begin("");
      while (LocalVariableDeclarationStatement_0());
      if (!Type()) return rejectInner();
      if (!VariableDeclarators()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  ForInit_1 = StatementExpression (COMMA StatementExpression)*
  //-------------------------------------------------------------------
  private boolean ForInit_1()
    {
      begin("");
      if (!StatementExpression()) return rejectInner();
      while (ForInit_2());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  ForInit_2 = COMMA StatementExpression
  //-------------------------------------------------------------------
  private boolean ForInit_2()
    {
      begin("");
      if (!COMMA()) return rejectInner();
      if (!StatementExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ForUpdate = StatementExpression (COMMA StatementExpression)* ;
  //=====================================================================
  private boolean ForUpdate()
    {
      begin("ForUpdate");
      if (!StatementExpression()) return reject();
      while (ForInit_2());
      return accept();
    }
  
  //=====================================================================
  //  EnumConstantName = Identifier ;
  //=====================================================================
  private boolean EnumConstantName()
    {
      begin("EnumConstantName");
      if (!Identifier()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  StatementExpression = Expression ;
  //=====================================================================
  private boolean StatementExpression()
    {
      begin("StatementExpression");
      if (!Expression()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ConstantExpression = Expression ;
  //=====================================================================
  private boolean ConstantExpression()
    {
      begin("ConstantExpression");
      if (!Expression()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Expression = ConditionalExpression (AssignmentOperator
  //    ConditionalExpression)* ;
  //=====================================================================
  private boolean Expression()
    {
      begin("Expression");
      if (!ConditionalExpression()) return reject();
      while (Expression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Expression_0 = AssignmentOperator ConditionalExpression
  //-------------------------------------------------------------------
  private boolean Expression_0()
    {
      begin("");
      if (!AssignmentOperator()) return rejectInner();
      if (!ConditionalExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  AssignmentOperator = EQU / PLUSEQU / MINUSEQU / STAREQU / DIVEQU /
  //    ANDEQU / OREQU / HATEQU / MODEQU / SLEQU / SREQU / BSREQU ;
  //=====================================================================
  private boolean AssignmentOperator()
    {
      begin("AssignmentOperator");
      if (EQU()) return accept();
      if (PLUSEQU()) return accept();
      if (MINUSEQU()) return accept();
      if (STAREQU()) return accept();
      if (DIVEQU()) return accept();
      if (ANDEQU()) return accept();
      if (OREQU()) return accept();
      if (HATEQU()) return accept();
      if (MODEQU()) return accept();
      if (SLEQU()) return accept();
      if (SREQU()) return accept();
      if (BSREQU()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  ConditionalExpression = ConditionalOrExpression (QUERY Expression
  //    COLON ConditionalOrExpression)* ;
  //=====================================================================
  private boolean ConditionalExpression()
    {
      begin("ConditionalExpression");
      if (!ConditionalOrExpression()) return reject();
      while (ConditionalExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ConditionalExpression_0 = QUERY Expression COLON
  //    ConditionalOrExpression
  //-------------------------------------------------------------------
  private boolean ConditionalExpression_0()
    {
      begin("");
      if (!QUERY()) return rejectInner();
      if (!Expression()) return rejectInner();
      if (!COLON()) return rejectInner();
      if (!ConditionalOrExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ConditionalOrExpression = ConditionalAndExpression (OROR
  //    ConditionalAndExpression)* ;
  //=====================================================================
  private boolean ConditionalOrExpression()
    {
      begin("ConditionalOrExpression");
      if (!ConditionalAndExpression()) return reject();
      while (ConditionalOrExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ConditionalOrExpression_0 = OROR ConditionalAndExpression
  //-------------------------------------------------------------------
  private boolean ConditionalOrExpression_0()
    {
      begin("");
      if (!OROR()) return rejectInner();
      if (!ConditionalAndExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ConditionalAndExpression = InclusiveOrExpression (ANDAND
  //    InclusiveOrExpression)* ;
  //=====================================================================
  private boolean ConditionalAndExpression()
    {
      begin("ConditionalAndExpression");
      if (!InclusiveOrExpression()) return reject();
      while (ConditionalAndExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ConditionalAndExpression_0 = ANDAND InclusiveOrExpression
  //-------------------------------------------------------------------
  private boolean ConditionalAndExpression_0()
    {
      begin("");
      if (!ANDAND()) return rejectInner();
      if (!InclusiveOrExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  InclusiveOrExpression = ExclusiveOrExpression (OR
  //    ExclusiveOrExpression)* ;
  //=====================================================================
  private boolean InclusiveOrExpression()
    {
      begin("InclusiveOrExpression");
      if (!ExclusiveOrExpression()) return reject();
      while (InclusiveOrExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  InclusiveOrExpression_0 = OR ExclusiveOrExpression
  //-------------------------------------------------------------------
  private boolean InclusiveOrExpression_0()
    {
      begin("");
      if (!OR()) return rejectInner();
      if (!ExclusiveOrExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ExclusiveOrExpression = AndExpression (HAT AndExpression)* ;
  //=====================================================================
  private boolean ExclusiveOrExpression()
    {
      begin("ExclusiveOrExpression");
      if (!AndExpression()) return reject();
      while (ExclusiveOrExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ExclusiveOrExpression_0 = HAT AndExpression
  //-------------------------------------------------------------------
  private boolean ExclusiveOrExpression_0()
    {
      begin("");
      if (!HAT()) return rejectInner();
      if (!AndExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  AndExpression = EqualityExpression (AND EqualityExpression)* ;
  //=====================================================================
  private boolean AndExpression()
    {
      begin("AndExpression");
      if (!EqualityExpression()) return reject();
      while (AndExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  AndExpression_0 = AND EqualityExpression
  //-------------------------------------------------------------------
  private boolean AndExpression_0()
    {
      begin("");
      if (!AND()) return rejectInner();
      if (!EqualityExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  EqualityExpression = RelationalExpression ((EQUAL / NOTEQUAL)
  //    RelationalExpression)* ;
  //=====================================================================
  private boolean EqualityExpression()
    {
      begin("EqualityExpression");
      if (!RelationalExpression()) return reject();
      while (EqualityExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  EqualityExpression_0 = (EQUAL / NOTEQUAL) RelationalExpression
  //-------------------------------------------------------------------
  private boolean EqualityExpression_0()
    {
      begin("");
      if (!EQUAL()
       && !NOTEQUAL()
         ) return rejectInner();
      if (!RelationalExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  RelationalExpression = ShiftExpression ((LE / GE / LT / GT)
  //    ShiftExpression / INSTANCEOF ReferenceType)* ;
  //=====================================================================
  private boolean RelationalExpression()
    {
      begin("RelationalExpression");
      if (!ShiftExpression()) return reject();
      while (RelationalExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  RelationalExpression_0 = (LE / GE / LT / GT) ShiftExpression /
  //    INSTANCEOF ReferenceType
  //-------------------------------------------------------------------
  private boolean RelationalExpression_0()
    {
      begin("");
      if (RelationalExpression_1()) return acceptInner();
      if (RelationalExpression_2()) return acceptInner();
      return rejectInner();
    }
  
  //-------------------------------------------------------------------
  //  RelationalExpression_1 = (LE / GE / LT / GT) ShiftExpression
  //-------------------------------------------------------------------
  private boolean RelationalExpression_1()
    {
      begin("");
      if (!LE()
       && !GE()
       && !LT()
       && !GT()
         ) return rejectInner();
      if (!ShiftExpression()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  RelationalExpression_2 = INSTANCEOF ReferenceType
  //-------------------------------------------------------------------
  private boolean RelationalExpression_2()
    {
      begin("");
      if (!INSTANCEOF()) return rejectInner();
      if (!ReferenceType()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ShiftExpression = AdditiveExpression ((SL / SR / BSR)
  //    AdditiveExpression)* ;
  //=====================================================================
  private boolean ShiftExpression()
    {
      begin("ShiftExpression");
      if (!AdditiveExpression()) return reject();
      while (ShiftExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ShiftExpression_0 = (SL / SR / BSR) AdditiveExpression
  //-------------------------------------------------------------------
  private boolean ShiftExpression_0()
    {
      begin("");
      if (!SL()
       && !SR()
       && !BSR()
         ) return rejectInner();
      if (!AdditiveExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  AdditiveExpression = MultiplicativeExpression ((PLUS / MINUS)
  //    MultiplicativeExpression)* ;
  //=====================================================================
  private boolean AdditiveExpression()
    {
      begin("AdditiveExpression");
      if (!MultiplicativeExpression()) return reject();
      while (AdditiveExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  AdditiveExpression_0 = (PLUS / MINUS) MultiplicativeExpression
  //-------------------------------------------------------------------
  private boolean AdditiveExpression_0()
    {
      begin("");
      if (!PLUS()
       && !MINUS()
         ) return rejectInner();
      if (!MultiplicativeExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  MultiplicativeExpression = UnaryExpression ((STAR / DIV / MOD)
  //    UnaryExpression)* ;
  //=====================================================================
  private boolean MultiplicativeExpression()
    {
      begin("MultiplicativeExpression");
      if (!UnaryExpression()) return reject();
      while (MultiplicativeExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  MultiplicativeExpression_0 = (STAR / DIV / MOD) UnaryExpression
  //-------------------------------------------------------------------
  private boolean MultiplicativeExpression_0()
    {
      begin("");
      if (!STAR()
       && !DIV()
       && !MOD()
         ) return rejectInner();
      if (!UnaryExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  UnaryExpression = PrefixOp UnaryExpression / LPAR Type RPAR
  //    UnaryExpression / Primary Selector* PostfixOp* ;
  //=====================================================================
  private boolean UnaryExpression()
    {
      begin("UnaryExpression");
      if (UnaryExpression_0()) return accept();
      if (UnaryExpression_1()) return accept();
      if (UnaryExpression_2()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  UnaryExpression_0 = PrefixOp UnaryExpression
  //-------------------------------------------------------------------
  private boolean UnaryExpression_0()
    {
      begin("");
      if (!PrefixOp()) return rejectInner();
      if (!UnaryExpression()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  UnaryExpression_1 = LPAR Type RPAR UnaryExpression
  //-------------------------------------------------------------------
  private boolean UnaryExpression_1()
    {
      begin("");
      if (!LPAR()) return rejectInner();
      if (!Type()) return rejectInner();
      if (!RPAR()) return rejectInner();
      if (!UnaryExpression()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  UnaryExpression_2 = Primary Selector* PostfixOp*
  //-------------------------------------------------------------------
  private boolean UnaryExpression_2()
    {
      begin("");
      if (!Primary()) return rejectInner();
      while (Selector());
      while (PostfixOp());
      return acceptInner();
    }
  
  //=====================================================================
  //  Primary = ParExpression / NonWildcardTypeArguments
  //    (ExplicitGenericInvocationSuffix / THIS Arguments) / THIS
  //    Arguments? / SUPER SuperSuffix / Literal / NEW Creator /
  //    QualifiedIdentifier IdentifierSuffix? / BasicType Dim* DOT CLASS
  //    / VOID DOT CLASS ;
  //=====================================================================
  private boolean Primary()
    {
      begin("Primary");
      if (ParExpression()) return accept();
      if (Primary_0()) return accept();
      if (Primary_1()) return accept();
      if (Primary_2()) return accept();
      if (Literal()) return accept();
      if (Primary_3()) return accept();
      if (Primary_4()) return accept();
      if (Primary_5()) return accept();
      if (Primary_6()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  Primary_0 = NonWildcardTypeArguments
  //    (ExplicitGenericInvocationSuffix / THIS Arguments)
  //-------------------------------------------------------------------
  private boolean Primary_0()
    {
      begin("");
      if (!NonWildcardTypeArguments()) return rejectInner();
      if (!ExplicitGenericInvocationSuffix()
       && !Primary_7()
         ) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Primary_1 = THIS Arguments?
  //-------------------------------------------------------------------
  private boolean Primary_1()
    {
      begin("");
      if (!THIS()) return rejectInner();
      Arguments();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Primary_2 = SUPER SuperSuffix
  //-------------------------------------------------------------------
  private boolean Primary_2()
    {
      begin("");
      if (!SUPER()) return rejectInner();
      if (!SuperSuffix()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Primary_3 = NEW Creator
  //-------------------------------------------------------------------
  private boolean Primary_3()
    {
      begin("");
      if (!NEW()) return rejectInner();
      if (!Creator()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Primary_4 = QualifiedIdentifier IdentifierSuffix?
  //-------------------------------------------------------------------
  private boolean Primary_4()
    {
      begin("");
      if (!QualifiedIdentifier()) return rejectInner();
      IdentifierSuffix();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Primary_5 = BasicType Dim* DOT CLASS
  //-------------------------------------------------------------------
  private boolean Primary_5()
    {
      begin("");
      if (!BasicType()) return rejectInner();
      while (Dim());
      if (!DOT()) return rejectInner();
      if (!CLASS()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Primary_6 = VOID DOT CLASS
  //-------------------------------------------------------------------
  private boolean Primary_6()
    {
      begin("");
      if (!VOID()) return rejectInner();
      if (!DOT()) return rejectInner();
      if (!CLASS()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Primary_7 = THIS Arguments
  //-------------------------------------------------------------------
  private boolean Primary_7()
    {
      begin("");
      if (!THIS()) return rejectInner();
      if (!Arguments()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  IdentifierSuffix = LBRK (RBRK Dim* DOT CLASS / Expression RBRK) /
  //    Arguments / DOT (CLASS / ExplicitGenericInvocation / THIS / SUPER
  //    Arguments / NEW NonWildcardTypeArguments? InnerCreator) ;
  //=====================================================================
  private boolean IdentifierSuffix()
    {
      begin("IdentifierSuffix");
      if (IdentifierSuffix_0()) return accept();
      if (Arguments()) return accept();
      if (IdentifierSuffix_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  IdentifierSuffix_0 = LBRK (RBRK Dim* DOT CLASS / Expression
  //    RBRK)
  //-------------------------------------------------------------------
  private boolean IdentifierSuffix_0()
    {
      begin("");
      if (!LBRK()) return rejectInner();
      if (!IdentifierSuffix_2()
       && !IdentifierSuffix_3()
         ) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  IdentifierSuffix_1 = DOT (CLASS / ExplicitGenericInvocation /
  //    THIS / SUPER Arguments / NEW NonWildcardTypeArguments?
  //    InnerCreator)
  //-------------------------------------------------------------------
  private boolean IdentifierSuffix_1()
    {
      begin("");
      if (!DOT()) return rejectInner();
      if (!CLASS()
       && !ExplicitGenericInvocation()
       && !THIS()
       && !IdentifierSuffix_4()
       && !IdentifierSuffix_5()
         ) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  IdentifierSuffix_2 = RBRK Dim* DOT CLASS
  //-------------------------------------------------------------------
  private boolean IdentifierSuffix_2()
    {
      begin("");
      if (!RBRK()) return rejectInner();
      while (Dim());
      if (!DOT()) return rejectInner();
      if (!CLASS()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  IdentifierSuffix_3 = Expression RBRK
  //-------------------------------------------------------------------
  private boolean IdentifierSuffix_3()
    {
      begin("");
      if (!Expression()) return rejectInner();
      if (!RBRK()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  IdentifierSuffix_4 = SUPER Arguments
  //-------------------------------------------------------------------
  private boolean IdentifierSuffix_4()
    {
      begin("");
      if (!SUPER()) return rejectInner();
      if (!Arguments()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  IdentifierSuffix_5 = NEW NonWildcardTypeArguments? InnerCreator
  //-------------------------------------------------------------------
  private boolean IdentifierSuffix_5()
    {
      begin("");
      if (!NEW()) return rejectInner();
      NonWildcardTypeArguments();
      if (!InnerCreator()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ExplicitGenericInvocation = NonWildcardTypeArguments
  //    ExplicitGenericInvocationSuffix ;
  //=====================================================================
  private boolean ExplicitGenericInvocation()
    {
      begin("ExplicitGenericInvocation");
      if (!NonWildcardTypeArguments()) return reject();
      if (!ExplicitGenericInvocationSuffix()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  NonWildcardTypeArguments = LPOINT ReferenceType (COMMA
  //    ReferenceType)* RPOINT ;
  //=====================================================================
  private boolean NonWildcardTypeArguments()
    {
      begin("NonWildcardTypeArguments");
      if (!LPOINT()) return reject();
      if (!ReferenceType()) return reject();
      while (NonWildcardTypeArguments_0());
      if (!RPOINT()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  NonWildcardTypeArguments_0 = COMMA ReferenceType
  //-------------------------------------------------------------------
  private boolean NonWildcardTypeArguments_0()
    {
      begin("");
      if (!COMMA()) return rejectInner();
      if (!ReferenceType()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  TypeArgumentsOrDiamond = LPOINT RPOINT / TypeArguments ;
  //=====================================================================
  private boolean TypeArgumentsOrDiamond()
    {
      begin("TypeArgumentsOrDiamond");
      if (TypeArgumentsOrDiamond_0()) return accept();
      if (TypeArguments()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  TypeArgumentsOrDiamond_0 = LPOINT RPOINT
  //-------------------------------------------------------------------
  private boolean TypeArgumentsOrDiamond_0()
    {
      begin("");
      if (!LPOINT()) return rejectInner();
      if (!RPOINT()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  NonWildcardTypeArgumentsOrDiamond = LPOINT RPOINT /
  //    NonWildcardTypeArguments ;
  //=====================================================================
  private boolean NonWildcardTypeArgumentsOrDiamond()
    {
      begin("NonWildcardTypeArgumentsOrDiamond");
      if (TypeArgumentsOrDiamond_0()) return accept();
      if (NonWildcardTypeArguments()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  ExplicitGenericInvocationSuffix = SUPER SuperSuffix / Identifier
  //    Arguments ;
  //=====================================================================
  private boolean ExplicitGenericInvocationSuffix()
    {
      begin("ExplicitGenericInvocationSuffix");
      if (Primary_2()) return accept();
      if (ExplicitGenericInvocationSuffix_0()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  ExplicitGenericInvocationSuffix_0 = Identifier Arguments
  //-------------------------------------------------------------------
  private boolean ExplicitGenericInvocationSuffix_0()
    {
      begin("");
      if (!Identifier()) return rejectInner();
      if (!Arguments()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  PrefixOp = INC / DEC / BANG / TILDA / PLUS / MINUS ;
  //=====================================================================
  private boolean PrefixOp()
    {
      begin("PrefixOp");
      if (INC()) return accept();
      if (DEC()) return accept();
      if (BANG()) return accept();
      if (TILDA()) return accept();
      if (PLUS()) return accept();
      if (MINUS()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  PostfixOp = INC / DEC ;
  //=====================================================================
  private boolean PostfixOp()
    {
      begin("PostfixOp");
      if (INC()) return accept();
      if (DEC()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Selector = DOT Identifier Arguments? / DOT
  //    ExplicitGenericInvocation / DOT THIS / DOT SUPER SuperSuffix /
  //    DOT NEW NonWildcardTypeArguments? InnerCreator / DimExpr ;
  //=====================================================================
  private boolean Selector()
    {
      begin("Selector");
      if (Selector_0()) return accept();
      if (Selector_1()) return accept();
      if (Selector_2()) return accept();
      if (Selector_3()) return accept();
      if (Selector_4()) return accept();
      if (DimExpr()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  Selector_0 = DOT Identifier Arguments?
  //-------------------------------------------------------------------
  private boolean Selector_0()
    {
      begin("");
      if (!DOT()) return rejectInner();
      if (!Identifier()) return rejectInner();
      Arguments();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Selector_1 = DOT ExplicitGenericInvocation
  //-------------------------------------------------------------------
  private boolean Selector_1()
    {
      begin("");
      if (!DOT()) return rejectInner();
      if (!ExplicitGenericInvocation()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Selector_2 = DOT THIS
  //-------------------------------------------------------------------
  private boolean Selector_2()
    {
      begin("");
      if (!DOT()) return rejectInner();
      if (!THIS()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Selector_3 = DOT SUPER SuperSuffix
  //-------------------------------------------------------------------
  private boolean Selector_3()
    {
      begin("");
      if (!DOT()) return rejectInner();
      if (!SUPER()) return rejectInner();
      if (!SuperSuffix()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Selector_4 = DOT NEW NonWildcardTypeArguments? InnerCreator
  //-------------------------------------------------------------------
  private boolean Selector_4()
    {
      begin("");
      if (!DOT()) return rejectInner();
      if (!NEW()) return rejectInner();
      NonWildcardTypeArguments();
      if (!InnerCreator()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  SuperSuffix = Arguments / DOT NonWildcardTypeArguments? Identifier
  //    Arguments? ;
  //=====================================================================
  private boolean SuperSuffix()
    {
      begin("SuperSuffix");
      if (Arguments()) return accept();
      if (SuperSuffix_0()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  SuperSuffix_0 = DOT NonWildcardTypeArguments? Identifier
  //    Arguments?
  //-------------------------------------------------------------------
  private boolean SuperSuffix_0()
    {
      begin("");
      if (!DOT()) return rejectInner();
      NonWildcardTypeArguments();
      if (!Identifier()) return rejectInner();
      Arguments();
      return acceptInner();
    }
  
  //=====================================================================
  //  BasicType = ("byte" / "short" / "char" / "int" / "long" / "float" /
  //    "double" / "boolean") !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean BasicType()
    {
      begin("BasicType");
      if (!next("byte")
       && !next("short")
       && !next("char")
       && !next("int")
       && !next("long")
       && !next("float")
       && !next("double")
       && !next("boolean")
         ) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  BasicType_0 = !LetterOrDigit
  //-------------------------------------------------------------------
  private boolean BasicType_0()
    {
      begin("","not LetterOrDigit");
      if (LetterOrDigit()) return rejectPred();
      return acceptPred();
    }
  
  //=====================================================================
  //  Arguments = LPAR (Expression (COMMA Expression)*)? RPAR ;
  //=====================================================================
  private boolean Arguments()
    {
      begin("Arguments");
      if (!LPAR()) return reject();
      Arguments_0();
      if (!RPAR()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Arguments_0 = Expression (COMMA Expression)*
  //-------------------------------------------------------------------
  private boolean Arguments_0()
    {
      begin("");
      if (!Expression()) return rejectInner();
      while (Arguments_1());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Arguments_1 = COMMA Expression
  //-------------------------------------------------------------------
  private boolean Arguments_1()
    {
      begin("");
      if (!COMMA()) return rejectInner();
      if (!Expression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Creator = (BasicType / CreatedName) ArrayCreatorRest /
  //    NonWildcardTypeArguments? CreatedName ClassCreatorRest ;
  //=====================================================================
  private boolean Creator()
    {
      begin("Creator");
      if (Creator_0()) return accept();
      if (Creator_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  Creator_0 = (BasicType / CreatedName) ArrayCreatorRest
  //-------------------------------------------------------------------
  private boolean Creator_0()
    {
      begin("");
      if (!BasicType()
       && !CreatedName()
         ) return rejectInner();
      if (!ArrayCreatorRest()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Creator_1 = NonWildcardTypeArguments? CreatedName
  //    ClassCreatorRest
  //-------------------------------------------------------------------
  private boolean Creator_1()
    {
      begin("");
      NonWildcardTypeArguments();
      if (!CreatedName()) return rejectInner();
      if (!ClassCreatorRest()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  CreatedName = Identifier TypeArgumentsOrDiamond? (DOT Identifier
  //    TypeArgumentsOrDiamond?)* ;
  //=====================================================================
  private boolean CreatedName()
    {
      begin("CreatedName");
      if (!Identifier()) return reject();
      TypeArgumentsOrDiamond();
      while (CreatedName_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  CreatedName_0 = DOT Identifier TypeArgumentsOrDiamond?
  //-------------------------------------------------------------------
  private boolean CreatedName_0()
    {
      begin("");
      if (!DOT()) return rejectInner();
      if (!Identifier()) return rejectInner();
      TypeArgumentsOrDiamond();
      return acceptInner();
    }
  
  //=====================================================================
  //  InnerCreator = Identifier NonWildcardTypeArgumentsOrDiamond?
  //    ClassCreatorRest ;
  //=====================================================================
  private boolean InnerCreator()
    {
      begin("InnerCreator");
      if (!Identifier()) return reject();
      NonWildcardTypeArgumentsOrDiamond();
      if (!ClassCreatorRest()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ClassCreatorRest = Arguments ClassBody? ;
  //=====================================================================
  private boolean ClassCreatorRest()
    {
      begin("ClassCreatorRest");
      if (!Arguments()) return reject();
      ClassBody();
      return accept();
    }
  
  //=====================================================================
  //  ArrayCreatorRest = Dim+ ArrayInitializer / DimExpr+ Dim* / Dim ;
  //=====================================================================
  private boolean ArrayCreatorRest()
    {
      begin("ArrayCreatorRest");
      if (ArrayCreatorRest_0()) return accept();
      if (ArrayCreatorRest_1()) return accept();
      if (Dim()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  ArrayCreatorRest_0 = Dim+ ArrayInitializer
  //-------------------------------------------------------------------
  private boolean ArrayCreatorRest_0()
    {
      begin("");
      if (!Dim()) return rejectInner();
      while (Dim());
      if (!ArrayInitializer()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  ArrayCreatorRest_1 = DimExpr+ Dim*
  //-------------------------------------------------------------------
  private boolean ArrayCreatorRest_1()
    {
      begin("");
      if (!DimExpr()) return rejectInner();
      while (DimExpr());
      while (Dim());
      return acceptInner();
    }
  
  //=====================================================================
  //  ArrayInitializer = LWING (VariableInitializer (COMMA
  //    VariableInitializer)*)? COMMA? RWING ;
  //=====================================================================
  private boolean ArrayInitializer()
    {
      begin("ArrayInitializer");
      if (!LWING()) return reject();
      ArrayInitializer_0();
      COMMA();
      if (!RWING()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ArrayInitializer_0 = VariableInitializer (COMMA
  //    VariableInitializer)*
  //-------------------------------------------------------------------
  private boolean ArrayInitializer_0()
    {
      begin("");
      if (!VariableInitializer()) return rejectInner();
      while (ArrayInitializer_1());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  ArrayInitializer_1 = COMMA VariableInitializer
  //-------------------------------------------------------------------
  private boolean ArrayInitializer_1()
    {
      begin("");
      if (!COMMA()) return rejectInner();
      if (!VariableInitializer()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  VariableInitializer = ArrayInitializer / Expression ;
  //=====================================================================
  private boolean VariableInitializer()
    {
      begin("VariableInitializer");
      if (ArrayInitializer()) return accept();
      if (Expression()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  ParExpression = LPAR Expression RPAR ;
  //=====================================================================
  private boolean ParExpression()
    {
      begin("ParExpression");
      if (!LPAR()) return reject();
      if (!Expression()) return reject();
      if (!RPAR()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  QualifiedIdentifier = Identifier (DOT Identifier)* ;
  //=====================================================================
  private boolean QualifiedIdentifier()
    {
      begin("QualifiedIdentifier");
      if (!Identifier()) return reject();
      while (QualifiedIdentifier_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  QualifiedIdentifier_0 = DOT Identifier
  //-------------------------------------------------------------------
  private boolean QualifiedIdentifier_0()
    {
      begin("");
      if (!DOT()) return rejectInner();
      if (!Identifier()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Dim = LBRK RBRK ;
  //=====================================================================
  private boolean Dim()
    {
      begin("Dim");
      if (!LBRK()) return reject();
      if (!RBRK()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  DimExpr = LBRK Expression RBRK ;
  //=====================================================================
  private boolean DimExpr()
    {
      begin("DimExpr");
      if (!LBRK()) return reject();
      if (!Expression()) return reject();
      if (!RBRK()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Type = (BasicType / ClassType) Dim* ;
  //=====================================================================
  private boolean Type()
    {
      begin("Type");
      if (!BasicType()
       && !ClassType()
         ) return reject();
      while (Dim());
      return accept();
    }
  
  //=====================================================================
  //  ReferenceType = BasicType Dim+ / ClassType Dim* ;
  //=====================================================================
  private boolean ReferenceType()
    {
      begin("ReferenceType");
      if (ReferenceType_0()) return accept();
      if (ReferenceType_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  ReferenceType_0 = BasicType Dim+
  //-------------------------------------------------------------------
  private boolean ReferenceType_0()
    {
      begin("");
      if (!BasicType()) return rejectInner();
      if (!Dim()) return rejectInner();
      while (Dim());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  ReferenceType_1 = ClassType Dim*
  //-------------------------------------------------------------------
  private boolean ReferenceType_1()
    {
      begin("");
      if (!ClassType()) return rejectInner();
      while (Dim());
      return acceptInner();
    }
  
  //=====================================================================
  //  ClassType = Identifier TypeArguments? (DOT Identifier
  //    TypeArguments?)* ;
  //=====================================================================
  private boolean ClassType()
    {
      begin("ClassType");
      if (!Identifier()) return reject();
      TypeArguments();
      while (ClassType_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ClassType_0 = DOT Identifier TypeArguments?
  //-------------------------------------------------------------------
  private boolean ClassType_0()
    {
      begin("");
      if (!DOT()) return rejectInner();
      if (!Identifier()) return rejectInner();
      TypeArguments();
      return acceptInner();
    }
  
  //=====================================================================
  //  ClassTypeList = ClassType (COMMA ClassType)* ;
  //=====================================================================
  private boolean ClassTypeList()
    {
      begin("ClassTypeList");
      if (!ClassType()) return reject();
      while (ClassTypeList_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ClassTypeList_0 = COMMA ClassType
  //-------------------------------------------------------------------
  private boolean ClassTypeList_0()
    {
      begin("");
      if (!COMMA()) return rejectInner();
      if (!ClassType()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  TypeArguments = LPOINT TypeArgument (COMMA TypeArgument)* RPOINT ;
  //=====================================================================
  private boolean TypeArguments()
    {
      begin("TypeArguments");
      if (!LPOINT()) return reject();
      if (!TypeArgument()) return reject();
      while (TypeArguments_0());
      if (!RPOINT()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  TypeArguments_0 = COMMA TypeArgument
  //-------------------------------------------------------------------
  private boolean TypeArguments_0()
    {
      begin("");
      if (!COMMA()) return rejectInner();
      if (!TypeArgument()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  TypeArgument = ReferenceType / QUERY ((EXTENDS / SUPER)
  //    ReferenceType)? ;
  //=====================================================================
  private boolean TypeArgument()
    {
      begin("TypeArgument");
      if (ReferenceType()) return accept();
      if (TypeArgument_0()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  TypeArgument_0 = QUERY ((EXTENDS / SUPER) ReferenceType)?
  //-------------------------------------------------------------------
  private boolean TypeArgument_0()
    {
      begin("");
      if (!QUERY()) return rejectInner();
      TypeArgument_1();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TypeArgument_1 = (EXTENDS / SUPER) ReferenceType
  //-------------------------------------------------------------------
  private boolean TypeArgument_1()
    {
      begin("");
      if (!EXTENDS()
       && !SUPER()
         ) return rejectInner();
      if (!ReferenceType()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  TypeParameters = LPOINT TypeParameter (COMMA TypeParameter)* RPOINT
  //    ;
  //=====================================================================
  private boolean TypeParameters()
    {
      begin("TypeParameters");
      if (!LPOINT()) return reject();
      if (!TypeParameter()) return reject();
      while (TypeParameters_0());
      if (!RPOINT()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  TypeParameters_0 = COMMA TypeParameter
  //-------------------------------------------------------------------
  private boolean TypeParameters_0()
    {
      begin("");
      if (!COMMA()) return rejectInner();
      if (!TypeParameter()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  TypeParameter = Identifier (EXTENDS Bound)? ;
  //=====================================================================
  private boolean TypeParameter()
    {
      begin("TypeParameter");
      if (!Identifier()) return reject();
      TypeParameter_0();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  TypeParameter_0 = EXTENDS Bound
  //-------------------------------------------------------------------
  private boolean TypeParameter_0()
    {
      begin("");
      if (!EXTENDS()) return rejectInner();
      if (!Bound()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Bound = ClassType (AND ClassType)* ;
  //=====================================================================
  private boolean Bound()
    {
      begin("Bound");
      if (!ClassType()) return reject();
      while (Bound_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Bound_0 = AND ClassType
  //-------------------------------------------------------------------
  private boolean Bound_0()
    {
      begin("");
      if (!AND()) return rejectInner();
      if (!ClassType()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Modifier = Annotation / ("public" / "protected" / "private" /
  //    "static" / "abstract" / "final" / "native" / "synchronized" /
  //    "transient" / "volatile" / "strictfp") !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean Modifier()
    {
      begin("Modifier");
      if (Annotation()) return accept();
      if (Modifier_0()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  Modifier_0 = ("public" / "protected" / "private" / "static" /
  //    "abstract" / "final" / "native" / "synchronized" / "transient"
  //    / "volatile" / "strictfp") !LetterOrDigit Spacing
  //-------------------------------------------------------------------
  private boolean Modifier_0()
    {
      begin("");
      if (!next("public")
       && !next("protected")
       && !next("private")
       && !next("static")
       && !next("abstract")
       && !next("final")
       && !next("native")
       && !next("synchronized")
       && !next("transient")
       && !next("volatile")
       && !next("strictfp")
         ) return rejectInner();
      if (!BasicType_0()) return rejectInner();
      Spacing();
      return acceptInner();
    }
  
  //=====================================================================
  //  AnnotationTypeDeclaration = AT INTERFACE Identifier
  //    AnnotationTypeBody ;
  //=====================================================================
  private boolean AnnotationTypeDeclaration()
    {
      begin("AnnotationTypeDeclaration");
      if (!AT()) return reject();
      if (!INTERFACE()) return reject();
      if (!Identifier()) return reject();
      if (!AnnotationTypeBody()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  AnnotationTypeBody = LWING AnnotationTypeElementDeclaration* RWING
  //    ;
  //=====================================================================
  private boolean AnnotationTypeBody()
    {
      begin("AnnotationTypeBody");
      if (!LWING()) return reject();
      while (AnnotationTypeElementDeclaration());
      if (!RWING()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  AnnotationTypeElementDeclaration = Modifier*
  //    AnnotationTypeElementRest / SEMI ;
  //=====================================================================
  private boolean AnnotationTypeElementDeclaration()
    {
      begin("AnnotationTypeElementDeclaration");
      if (AnnotationTypeElementDeclaration_0()) return accept();
      if (SEMI()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  AnnotationTypeElementDeclaration_0 = Modifier*
  //    AnnotationTypeElementRest
  //-------------------------------------------------------------------
  private boolean AnnotationTypeElementDeclaration_0()
    {
      begin("");
      while (Modifier());
      if (!AnnotationTypeElementRest()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  AnnotationTypeElementRest = Type AnnotationMethodOrConstantRest
  //    SEMI / ClassDeclaration / EnumDeclaration / InterfaceDeclaration
  //    / AnnotationTypeDeclaration ;
  //=====================================================================
  private boolean AnnotationTypeElementRest()
    {
      begin("AnnotationTypeElementRest");
      if (AnnotationTypeElementRest_0()) return accept();
      if (ClassDeclaration()) return accept();
      if (EnumDeclaration()) return accept();
      if (InterfaceDeclaration()) return accept();
      if (AnnotationTypeDeclaration()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  AnnotationTypeElementRest_0 = Type AnnotationMethodOrConstantRest
  //    SEMI
  //-------------------------------------------------------------------
  private boolean AnnotationTypeElementRest_0()
    {
      begin("");
      if (!Type()) return rejectInner();
      if (!AnnotationMethodOrConstantRest()) return rejectInner();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  AnnotationMethodOrConstantRest = AnnotationMethodRest /
  //    AnnotationConstantRest ;
  //=====================================================================
  private boolean AnnotationMethodOrConstantRest()
    {
      begin("AnnotationMethodOrConstantRest");
      if (AnnotationMethodRest()) return accept();
      if (AnnotationConstantRest()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  AnnotationMethodRest = Identifier LPAR RPAR DefaultValue? ;
  //=====================================================================
  private boolean AnnotationMethodRest()
    {
      begin("AnnotationMethodRest");
      if (!Identifier()) return reject();
      if (!LPAR()) return reject();
      if (!RPAR()) return reject();
      DefaultValue();
      return accept();
    }
  
  //=====================================================================
  //  AnnotationConstantRest = VariableDeclarators ;
  //=====================================================================
  private boolean AnnotationConstantRest()
    {
      begin("AnnotationConstantRest");
      if (!VariableDeclarators()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  DefaultValue = DEFAULT ElementValue ;
  //=====================================================================
  private boolean DefaultValue()
    {
      begin("DefaultValue");
      if (!DEFAULT()) return reject();
      if (!ElementValue()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Annotation = NormalAnnotation / SingleElementAnnotation /
  //    MarkerAnnotation ;
  //=====================================================================
  private boolean Annotation()
    {
      begin("Annotation");
      if (NormalAnnotation()) return accept();
      if (SingleElementAnnotation()) return accept();
      if (MarkerAnnotation()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  NormalAnnotation = AT QualifiedIdentifier LPAR ElementValuePairs?
  //    RPAR ;
  //=====================================================================
  private boolean NormalAnnotation()
    {
      begin("NormalAnnotation");
      if (!AT()) return reject();
      if (!QualifiedIdentifier()) return reject();
      if (!LPAR()) return reject();
      ElementValuePairs();
      if (!RPAR()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  SingleElementAnnotation = AT QualifiedIdentifier LPAR ElementValue
  //    RPAR ;
  //=====================================================================
  private boolean SingleElementAnnotation()
    {
      begin("SingleElementAnnotation");
      if (!AT()) return reject();
      if (!QualifiedIdentifier()) return reject();
      if (!LPAR()) return reject();
      if (!ElementValue()) return reject();
      if (!RPAR()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  MarkerAnnotation = AT QualifiedIdentifier ;
  //=====================================================================
  private boolean MarkerAnnotation()
    {
      begin("MarkerAnnotation");
      if (!AT()) return reject();
      if (!QualifiedIdentifier()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ElementValuePairs = ElementValuePair (COMMA ElementValuePair)* ;
  //=====================================================================
  private boolean ElementValuePairs()
    {
      begin("ElementValuePairs");
      if (!ElementValuePair()) return reject();
      while (ElementValuePairs_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ElementValuePairs_0 = COMMA ElementValuePair
  //-------------------------------------------------------------------
  private boolean ElementValuePairs_0()
    {
      begin("");
      if (!COMMA()) return rejectInner();
      if (!ElementValuePair()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ElementValuePair = Identifier EQU ElementValue ;
  //=====================================================================
  private boolean ElementValuePair()
    {
      begin("ElementValuePair");
      if (!Identifier()) return reject();
      if (!EQU()) return reject();
      if (!ElementValue()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ElementValue = ConditionalExpression / Annotation /
  //    ElementValueArrayInitializer ;
  //=====================================================================
  private boolean ElementValue()
    {
      begin("ElementValue");
      if (ConditionalExpression()) return accept();
      if (Annotation()) return accept();
      if (ElementValueArrayInitializer()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  ElementValueArrayInitializer = LWING ElementValues? COMMA? RWING ;
  //=====================================================================
  private boolean ElementValueArrayInitializer()
    {
      begin("ElementValueArrayInitializer");
      if (!LWING()) return reject();
      ElementValues();
      COMMA();
      if (!RWING()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ElementValues = ElementValue (COMMA ElementValue)* ;
  //=====================================================================
  private boolean ElementValues()
    {
      begin("ElementValues");
      if (!ElementValue()) return reject();
      while (ElementValues_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ElementValues_0 = COMMA ElementValue
  //-------------------------------------------------------------------
  private boolean ElementValues_0()
    {
      begin("");
      if (!COMMA()) return rejectInner();
      if (!ElementValue()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Spacing = ([ \t\r\n\f]+ / "/*" (!"*/" _)* "*/" / "//" (![\r\n] _)*
  //    [\r\n])* ;
  //=====================================================================
  private boolean Spacing()
    {
      begin("Spacing");
      while (Spacing_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Spacing_0 = [ \t\r\n\f]+ / "/*" (!"*/" _)* "*/" / "//" (![\r\n]
  //    _)* [\r\n]
  //-------------------------------------------------------------------
  private boolean Spacing_0()
    {
      begin("");
      if (Spacing_1()) return acceptInner();
      if (Spacing_2()) return acceptInner();
      if (Spacing_3()) return acceptInner();
      return rejectInner();
    }
  
  //-------------------------------------------------------------------
  //  Spacing_1 = [ \t\r\n\f]+
  //-------------------------------------------------------------------
  private boolean Spacing_1()
    {
      begin("");
      if (!nextIn(" \t\r\n\f")) return rejectInner();
      while (nextIn(" \t\r\n\f"));
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Spacing_2 = "/*" (!"*/" _)* "*/"
  //-------------------------------------------------------------------
  private boolean Spacing_2()
    {
      begin("");
      if (!next("/*")) return rejectInner();
      while (Spacing_4());
      if (!next("*/")) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Spacing_3 = "//" (![\r\n] _)* [\r\n]
  //-------------------------------------------------------------------
  private boolean Spacing_3()
    {
      begin("");
      if (!next("//")) return rejectInner();
      while (Spacing_5());
      if (!nextIn("\r\n")) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Spacing_4 = !"*/" _
  //-------------------------------------------------------------------
  private boolean Spacing_4()
    {
      begin("");
      if (!aheadNot("*/")) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Spacing_5 = ![\r\n] _
  //-------------------------------------------------------------------
  private boolean Spacing_5()
    {
      begin("");
      if (!aheadNotIn("\r\n")) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Identifier = !Keyword Letter LetterOrDigit* Spacing ;
  //=====================================================================
  private boolean Identifier()
    {
      begin("Identifier");
      if (!Identifier_0()) return reject();
      if (!Letter()) return reject();
      while (LetterOrDigit());
      Spacing();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Identifier_0 = !Keyword
  //-------------------------------------------------------------------
  private boolean Identifier_0()
    {
      begin("","not Keyword");
      if (Keyword()) return rejectPred();
      return acceptPred();
    }
  
  //=====================================================================
  //  Letter = [a-z] / [A-Z] / [_$] ;
  //=====================================================================
  private boolean Letter()
    {
      begin("Letter");
      if (nextIn('a','z')) return accept();
      if (nextIn('A','Z')) return accept();
      if (nextIn("_$")) return accept();
      return reject();
    }
  
  //=====================================================================
  //  LetterOrDigit = [a-z] / [A-Z] / [0-9] / [_$] ;
  //=====================================================================
  private boolean LetterOrDigit()
    {
      begin("LetterOrDigit");
      if (nextIn('a','z')) return accept();
      if (nextIn('A','Z')) return accept();
      if (nextIn('0','9')) return accept();
      if (nextIn("_$")) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Keyword = ("abstract" / "assert" / "boolean" / "break" / "byte" /
  //    "case" / "catch" / "char" / "class" / "const" / "continue" /
  //    "default" / "double" / "do" / "else" / "enum" / "extends" /
  //    "false" / "finally" / "final" / "float" / "for" / "goto" / "if" /
  //    "implements" / "import" / "interface" / "int" / "instanceof" /
  //    "long" / "native" / "new" / "null" / "package" / "private" /
  //    "protected" / "public" / "return" / "short" / "static" /
  //    "strictfp" / "super" / "switch" / "synchronized" / "this" /
  //    "throws" / "throw" / "transient" / "true" / "try" / "void" /
  //    "volatile" / "while") !LetterOrDigit ;
  //=====================================================================
  private boolean Keyword()
    {
      begin("Keyword");
      if (!next("abstract")
       && !next("assert")
       && !next("boolean")
       && !next("break")
       && !next("byte")
       && !next("case")
       && !next("catch")
       && !next("char")
       && !next("class")
       && !next("const")
       && !next("continue")
       && !next("default")
       && !next("double")
       && !next("do")
       && !next("else")
       && !next("enum")
       && !next("extends")
       && !next("false")
       && !next("finally")
       && !next("final")
       && !next("float")
       && !next("for")
       && !next("goto")
       && !next("if")
       && !next("implements")
       && !next("import")
       && !next("interface")
       && !next("int")
       && !next("instanceof")
       && !next("long")
       && !next("native")
       && !next("new")
       && !next("null")
       && !next("package")
       && !next("private")
       && !next("protected")
       && !next("public")
       && !next("return")
       && !next("short")
       && !next("static")
       && !next("strictfp")
       && !next("super")
       && !next("switch")
       && !next("synchronized")
       && !next("this")
       && !next("throws")
       && !next("throw")
       && !next("transient")
       && !next("true")
       && !next("try")
       && !next("void")
       && !next("volatile")
       && !next("while")
         ) return reject();
      if (!BasicType_0()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ASSERT = "assert" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean ASSERT()
    {
      begin("ASSERT");
      if (!next("assert")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  BREAK = "break" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean BREAK()
    {
      begin("BREAK");
      if (!next("break")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  CASE = "case" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean CASE()
    {
      begin("CASE");
      if (!next("case")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  CATCH = "catch" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean CATCH()
    {
      begin("CATCH");
      if (!next("catch")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  CLASS = "class" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean CLASS()
    {
      begin("CLASS");
      if (!next("class")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  CONTINUE = "continue" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean CONTINUE()
    {
      begin("CONTINUE");
      if (!next("continue")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  DEFAULT = "default" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean DEFAULT()
    {
      begin("DEFAULT");
      if (!next("default")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  DO = "do" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean DO()
    {
      begin("DO");
      if (!next("do")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  ELSE = "else" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean ELSE()
    {
      begin("ELSE");
      if (!next("else")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  ENUM = "enum" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean ENUM()
    {
      begin("ENUM");
      if (!next("enum")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  EXTENDS = "extends" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean EXTENDS()
    {
      begin("EXTENDS");
      if (!next("extends")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  FINALLY = "finally" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean FINALLY()
    {
      begin("FINALLY");
      if (!next("finally")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  FINAL = "final" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean FINAL()
    {
      begin("FINAL");
      if (!next("final")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  FOR = "for" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean FOR()
    {
      begin("FOR");
      if (!next("for")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  IF = "if" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean IF()
    {
      begin("IF");
      if (!next("if")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  IMPLEMENTS = "implements" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean IMPLEMENTS()
    {
      begin("IMPLEMENTS");
      if (!next("implements")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  IMPORT = "import" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean IMPORT()
    {
      begin("IMPORT");
      if (!next("import")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  INTERFACE = "interface" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean INTERFACE()
    {
      begin("INTERFACE");
      if (!next("interface")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  INSTANCEOF = "instanceof" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean INSTANCEOF()
    {
      begin("INSTANCEOF");
      if (!next("instanceof")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  NEW = "new" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean NEW()
    {
      begin("NEW");
      if (!next("new")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  PACKAGE = "package" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean PACKAGE()
    {
      begin("PACKAGE");
      if (!next("package")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  RETURN = "return" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean RETURN()
    {
      begin("RETURN");
      if (!next("return")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  STATIC = "static" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean STATIC()
    {
      begin("STATIC");
      if (!next("static")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  SUPER = "super" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean SUPER()
    {
      begin("SUPER");
      if (!next("super")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  SWITCH = "switch" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean SWITCH()
    {
      begin("SWITCH");
      if (!next("switch")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  SYNCHRONIZED = "synchronized" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean SYNCHRONIZED()
    {
      begin("SYNCHRONIZED");
      if (!next("synchronized")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  THIS = "this" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean THIS()
    {
      begin("THIS");
      if (!next("this")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  THROWS = "throws" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean THROWS()
    {
      begin("THROWS");
      if (!next("throws")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  THROW = "throw" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean THROW()
    {
      begin("THROW");
      if (!next("throw")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  TRY = "try" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean TRY()
    {
      begin("TRY");
      if (!next("try")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  VOID = "void" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean VOID()
    {
      begin("VOID");
      if (!next("void")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  WHILE = "while" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean WHILE()
    {
      begin("WHILE");
      if (!next("while")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  Literal = (FloatLiteral / IntegerLiteral / CharLiteral /
  //    StringLiteral / "true" !LetterOrDigit / "false" !LetterOrDigit /
  //    "null" !LetterOrDigit) Spacing ;
  //=====================================================================
  private boolean Literal()
    {
      begin("Literal");
      if (!FloatLiteral()
       && !IntegerLiteral()
       && !CharLiteral()
       && !StringLiteral()
       && !Literal_0()
       && !Literal_1()
       && !Literal_2()
         ) return reject();
      Spacing();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Literal_0 = "true" !LetterOrDigit
  //-------------------------------------------------------------------
  private boolean Literal_0()
    {
      begin("");
      if (!next("true")) return rejectInner();
      if (!BasicType_0()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Literal_1 = "false" !LetterOrDigit
  //-------------------------------------------------------------------
  private boolean Literal_1()
    {
      begin("");
      if (!next("false")) return rejectInner();
      if (!BasicType_0()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Literal_2 = "null" !LetterOrDigit
  //-------------------------------------------------------------------
  private boolean Literal_2()
    {
      begin("");
      if (!next("null")) return rejectInner();
      if (!BasicType_0()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  IntegerLiteral = (HexNumeral / BinaryNumeral / OctalNumeral /
  //    DecimalNumeral) [lL]? ;
  //=====================================================================
  private boolean IntegerLiteral()
    {
      begin("IntegerLiteral");
      if (!HexNumeral()
       && !BinaryNumeral()
       && !OctalNumeral()
       && !DecimalNumeral()
         ) return reject();
      nextIn("lL");
      return accept();
    }
  
  //=====================================================================
  //  DecimalNumeral = "0" / [1-9] ([_]* [0-9])* ;
  //=====================================================================
  private boolean DecimalNumeral()
    {
      begin("DecimalNumeral");
      if (next('0')) return accept();
      if (DecimalNumeral_0()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  DecimalNumeral_0 = [1-9] ([_]* [0-9])*
  //-------------------------------------------------------------------
  private boolean DecimalNumeral_0()
    {
      begin("");
      if (!nextIn('1','9')) return rejectInner();
      while (DecimalNumeral_1());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  DecimalNumeral_1 = [_]* [0-9]
  //-------------------------------------------------------------------
  private boolean DecimalNumeral_1()
    {
      begin("");
      while (next('_'));
      if (!nextIn('0','9')) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  HexNumeral = ("0x" / "0X") HexDigits ;
  //=====================================================================
  private boolean HexNumeral()
    {
      begin("HexNumeral");
      if (!next("0x")
       && !next("0X")
         ) return reject();
      if (!HexDigits()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  BinaryNumeral = ("0b" / "0B") [01] ([_]* [01])* ;
  //=====================================================================
  private boolean BinaryNumeral()
    {
      begin("BinaryNumeral");
      if (!next("0b")
       && !next("0B")
         ) return reject();
      if (!nextIn("01")) return reject();
      while (BinaryNumeral_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  BinaryNumeral_0 = [_]* [01]
  //-------------------------------------------------------------------
  private boolean BinaryNumeral_0()
    {
      begin("");
      while (next('_'));
      if (!nextIn("01")) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  OctalNumeral = "0" ([_]* [0-7])+ ;
  //=====================================================================
  private boolean OctalNumeral()
    {
      begin("OctalNumeral");
      if (!next('0')) return reject();
      if (!OctalNumeral_0()) return reject();
      while (OctalNumeral_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  OctalNumeral_0 = [_]* [0-7]
  //-------------------------------------------------------------------
  private boolean OctalNumeral_0()
    {
      begin("");
      while (next('_'));
      if (!nextIn('0','7')) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  FloatLiteral = HexFloat / DecimalFloat ;
  //=====================================================================
  private boolean FloatLiteral()
    {
      begin("FloatLiteral");
      if (HexFloat()) return accept();
      if (DecimalFloat()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  DecimalFloat = Digits "." Digits? Exponent? [fFdD]? / "." Digits
  //    Exponent? [fFdD]? / Digits Exponent [fFdD]? / Digits Exponent?
  //    [fFdD] ;
  //=====================================================================
  private boolean DecimalFloat()
    {
      begin("DecimalFloat");
      if (DecimalFloat_0()) return accept();
      if (DecimalFloat_1()) return accept();
      if (DecimalFloat_2()) return accept();
      if (DecimalFloat_3()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  DecimalFloat_0 = Digits "." Digits? Exponent? [fFdD]?
  //-------------------------------------------------------------------
  private boolean DecimalFloat_0()
    {
      begin("");
      if (!Digits()) return rejectInner();
      if (!next('.')) return rejectInner();
      Digits();
      Exponent();
      nextIn("fFdD");
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  DecimalFloat_1 = "." Digits Exponent? [fFdD]?
  //-------------------------------------------------------------------
  private boolean DecimalFloat_1()
    {
      begin("");
      if (!next('.')) return rejectInner();
      if (!Digits()) return rejectInner();
      Exponent();
      nextIn("fFdD");
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  DecimalFloat_2 = Digits Exponent [fFdD]?
  //-------------------------------------------------------------------
  private boolean DecimalFloat_2()
    {
      begin("");
      if (!Digits()) return rejectInner();
      if (!Exponent()) return rejectInner();
      nextIn("fFdD");
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  DecimalFloat_3 = Digits Exponent? [fFdD]
  //-------------------------------------------------------------------
  private boolean DecimalFloat_3()
    {
      begin("");
      if (!Digits()) return rejectInner();
      Exponent();
      if (!nextIn("fFdD")) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Exponent = [eE] [+-]? Digits ;
  //=====================================================================
  private boolean Exponent()
    {
      begin("Exponent");
      if (!nextIn("eE")) return reject();
      nextIn("+-");
      if (!Digits()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  HexFloat = HexSignificand BinaryExponent [fFdD]? ;
  //=====================================================================
  private boolean HexFloat()
    {
      begin("HexFloat");
      if (!HexSignificand()) return reject();
      if (!BinaryExponent()) return reject();
      nextIn("fFdD");
      return accept();
    }
  
  //=====================================================================
  //  HexSignificand = ("0x" / "0X") HexDigits? "." HexDigits /
  //    HexNumeral "."? ;
  //=====================================================================
  private boolean HexSignificand()
    {
      begin("HexSignificand");
      if (HexSignificand_0()) return accept();
      if (HexSignificand_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  HexSignificand_0 = ("0x" / "0X") HexDigits? "." HexDigits
  //-------------------------------------------------------------------
  private boolean HexSignificand_0()
    {
      begin("");
      if (!next("0x")
       && !next("0X")
         ) return rejectInner();
      HexDigits();
      if (!next('.')) return rejectInner();
      if (!HexDigits()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  HexSignificand_1 = HexNumeral "."?
  //-------------------------------------------------------------------
  private boolean HexSignificand_1()
    {
      begin("");
      if (!HexNumeral()) return rejectInner();
      next('.');
      return acceptInner();
    }
  
  //=====================================================================
  //  BinaryExponent = [pP] [+-]? Digits ;
  //=====================================================================
  private boolean BinaryExponent()
    {
      begin("BinaryExponent");
      if (!nextIn("pP")) return reject();
      nextIn("+-");
      if (!Digits()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Digits = [0-9] ([_]* [0-9])* ;
  //=====================================================================
  private boolean Digits()
    {
      begin("Digits");
      if (!nextIn('0','9')) return reject();
      while (DecimalNumeral_1());
      return accept();
    }
  
  //=====================================================================
  //  HexDigits = HexDigit ([_]* HexDigit)* ;
  //=====================================================================
  private boolean HexDigits()
    {
      begin("HexDigits");
      if (!HexDigit()) return reject();
      while (HexDigits_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  HexDigits_0 = [_]* HexDigit
  //-------------------------------------------------------------------
  private boolean HexDigits_0()
    {
      begin("");
      while (next('_'));
      if (!HexDigit()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  HexDigit = [a-f] / [A-F] / [0-9] ;
  //=====================================================================
  private boolean HexDigit()
    {
      begin("HexDigit");
      if (nextIn('a','f')) return accept();
      if (nextIn('A','F')) return accept();
      if (nextIn('0','9')) return accept();
      return reject();
    }
  
  //=====================================================================
  //  CharLiteral = "'" (Escape / !['\\n\r] _) "'" ;
  //=====================================================================
  private boolean CharLiteral()
    {
      begin("CharLiteral");
      if (!next('\'')) return reject();
      if (!Escape()
       && !CharLiteral_0()
         ) return reject();
      if (!next('\'')) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  CharLiteral_0 = !['\\n\r] _
  //-------------------------------------------------------------------
  private boolean CharLiteral_0()
    {
      begin("");
      if (!aheadNotIn("'\\\n\r")) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  StringLiteral = """ (Escape / !["\\n\r] _)* """ ;
  //=====================================================================
  private boolean StringLiteral()
    {
      begin("StringLiteral");
      if (!next('"')) return reject();
      while (StringLiteral_0());
      if (!next('"')) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  StringLiteral_0 = Escape / !["\\n\r] _
  //-------------------------------------------------------------------
  private boolean StringLiteral_0()
    {
      begin("");
      if (Escape()) return acceptInner();
      if (StringLiteral_1()) return acceptInner();
      return rejectInner();
    }
  
  //-------------------------------------------------------------------
  //  StringLiteral_1 = !["\\n\r] _
  //-------------------------------------------------------------------
  private boolean StringLiteral_1()
    {
      begin("");
      if (!aheadNotIn("\"\\\n\r")) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Escape = "\" ([btnfr"'\] / OctalEscape / UnicodeEscape) ;
  //=====================================================================
  private boolean Escape()
    {
      begin("Escape");
      if (!next('\\')) return reject();
      if (!nextIn("btnfr\"'\\")
       && !OctalEscape()
       && !UnicodeEscape()
         ) return reject();
      return accept();
    }
  
  //=====================================================================
  //  OctalEscape = [0-3] [0-7] [0-7] / [0-7] [0-7] / [0-7] ;
  //=====================================================================
  private boolean OctalEscape()
    {
      begin("OctalEscape");
      if (OctalEscape_0()) return accept();
      if (OctalEscape_1()) return accept();
      if (nextIn('0','7')) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  OctalEscape_0 = [0-3] [0-7] [0-7]
  //-------------------------------------------------------------------
  private boolean OctalEscape_0()
    {
      begin("");
      if (!nextIn('0','3')) return rejectInner();
      if (!nextIn('0','7')) return rejectInner();
      if (!nextIn('0','7')) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  OctalEscape_1 = [0-7] [0-7]
  //-------------------------------------------------------------------
  private boolean OctalEscape_1()
    {
      begin("");
      if (!nextIn('0','7')) return rejectInner();
      if (!nextIn('0','7')) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  UnicodeEscape = "u"+ HexDigit HexDigit HexDigit HexDigit ;
  //=====================================================================
  private boolean UnicodeEscape()
    {
      begin("UnicodeEscape");
      if (!next('u')) return reject();
      while (next('u'));
      if (!HexDigit()) return reject();
      if (!HexDigit()) return reject();
      if (!HexDigit()) return reject();
      if (!HexDigit()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  AT = "@" Spacing ;
  //=====================================================================
  private boolean AT()
    {
      begin("AT");
      if (!next('@')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  AND = "&" ![=&] Spacing ;
  //=====================================================================
  private boolean AND()
    {
      begin("AND");
      if (!next('&')) return reject();
      if (!aheadNotIn("=&")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  ANDAND = "&&" Spacing ;
  //=====================================================================
  private boolean ANDAND()
    {
      begin("ANDAND");
      if (!next("&&")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  ANDEQU = "&=" Spacing ;
  //=====================================================================
  private boolean ANDEQU()
    {
      begin("ANDEQU");
      if (!next("&=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  BANG = "!" !"=" Spacing ;
  //=====================================================================
  private boolean BANG()
    {
      begin("BANG");
      if (!next('!')) return reject();
      if (!aheadNot('=')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  BSR = ">>>" !"=" Spacing ;
  //=====================================================================
  private boolean BSR()
    {
      begin("BSR");
      if (!next(">>>")) return reject();
      if (!aheadNot('=')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  BSREQU = ">>>=" Spacing ;
  //=====================================================================
  private boolean BSREQU()
    {
      begin("BSREQU");
      if (!next(">>>=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  COLON = ":" Spacing ;
  //=====================================================================
  private boolean COLON()
    {
      begin("COLON");
      if (!next(':')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  COMMA = "," Spacing ;
  //=====================================================================
  private boolean COMMA()
    {
      begin("COMMA");
      if (!next(',')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  DEC = "--" Spacing ;
  //=====================================================================
  private boolean DEC()
    {
      begin("DEC");
      if (!next("--")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  DIV = "/" !"=" Spacing ;
  //=====================================================================
  private boolean DIV()
    {
      begin("DIV");
      if (!next('/')) return reject();
      if (!aheadNot('=')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  DIVEQU = "/=" Spacing ;
  //=====================================================================
  private boolean DIVEQU()
    {
      begin("DIVEQU");
      if (!next("/=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  DOT = "." Spacing ;
  //=====================================================================
  private boolean DOT()
    {
      begin("DOT");
      if (!next('.')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  ELLIPSIS = "..." Spacing ;
  //=====================================================================
  private boolean ELLIPSIS()
    {
      begin("ELLIPSIS");
      if (!next("...")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  EQU = "=" !"=" Spacing ;
  //=====================================================================
  private boolean EQU()
    {
      begin("EQU");
      if (!next('=')) return reject();
      if (!aheadNot('=')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  EQUAL = "==" Spacing ;
  //=====================================================================
  private boolean EQUAL()
    {
      begin("EQUAL");
      if (!next("==")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  GE = ">=" Spacing ;
  //=====================================================================
  private boolean GE()
    {
      begin("GE");
      if (!next(">=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  GT = ">" ![=>] Spacing ;
  //=====================================================================
  private boolean GT()
    {
      begin("GT");
      if (!next('>')) return reject();
      if (!aheadNotIn("=>")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  HAT = "^" !"=" Spacing ;
  //=====================================================================
  private boolean HAT()
    {
      begin("HAT");
      if (!next('^')) return reject();
      if (!aheadNot('=')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  HATEQU = "^=" Spacing ;
  //=====================================================================
  private boolean HATEQU()
    {
      begin("HATEQU");
      if (!next("^=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  INC = "++" Spacing ;
  //=====================================================================
  private boolean INC()
    {
      begin("INC");
      if (!next("++")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  LBRK = "[" Spacing ;
  //=====================================================================
  private boolean LBRK()
    {
      begin("LBRK");
      if (!next('[')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  LE = "<=" Spacing ;
  //=====================================================================
  private boolean LE()
    {
      begin("LE");
      if (!next("<=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  LPAR = "(" Spacing ;
  //=====================================================================
  private boolean LPAR()
    {
      begin("LPAR");
      if (!next('(')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  LPOINT = "<" Spacing ;
  //=====================================================================
  private boolean LPOINT()
    {
      begin("LPOINT");
      if (!next('<')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  LT = "<" ![=<] Spacing ;
  //=====================================================================
  private boolean LT()
    {
      begin("LT");
      if (!next('<')) return reject();
      if (!aheadNotIn("=<")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  LWING = "{" Spacing ;
  //=====================================================================
  private boolean LWING()
    {
      begin("LWING");
      if (!next('{')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  MINUS = "-" ![=-] Spacing ;
  //=====================================================================
  private boolean MINUS()
    {
      begin("MINUS");
      if (!next('-')) return reject();
      if (!aheadNotIn("=-")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  MINUSEQU = "-=" Spacing ;
  //=====================================================================
  private boolean MINUSEQU()
    {
      begin("MINUSEQU");
      if (!next("-=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  MOD = "%" !"=" Spacing ;
  //=====================================================================
  private boolean MOD()
    {
      begin("MOD");
      if (!next('%')) return reject();
      if (!aheadNot('=')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  MODEQU = "%=" Spacing ;
  //=====================================================================
  private boolean MODEQU()
    {
      begin("MODEQU");
      if (!next("%=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  NOTEQUAL = "!=" Spacing ;
  //=====================================================================
  private boolean NOTEQUAL()
    {
      begin("NOTEQUAL");
      if (!next("!=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  OR = "|" ![=|] Spacing ;
  //=====================================================================
  private boolean OR()
    {
      begin("OR");
      if (!next('|')) return reject();
      if (!aheadNotIn("=|")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  OREQU = "|=" Spacing ;
  //=====================================================================
  private boolean OREQU()
    {
      begin("OREQU");
      if (!next("|=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  OROR = "||" Spacing ;
  //=====================================================================
  private boolean OROR()
    {
      begin("OROR");
      if (!next("||")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  PLUS = "+" ![=+] Spacing ;
  //=====================================================================
  private boolean PLUS()
    {
      begin("PLUS");
      if (!next('+')) return reject();
      if (!aheadNotIn("=+")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  PLUSEQU = "+=" Spacing ;
  //=====================================================================
  private boolean PLUSEQU()
    {
      begin("PLUSEQU");
      if (!next("+=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  QUERY = "?" Spacing ;
  //=====================================================================
  private boolean QUERY()
    {
      begin("QUERY");
      if (!next('?')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  RBRK = "]" Spacing ;
  //=====================================================================
  private boolean RBRK()
    {
      begin("RBRK");
      if (!next(']')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  RPAR = ")" Spacing ;
  //=====================================================================
  private boolean RPAR()
    {
      begin("RPAR");
      if (!next(')')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  RPOINT = ">" Spacing ;
  //=====================================================================
  private boolean RPOINT()
    {
      begin("RPOINT");
      if (!next('>')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  RWING = "}" Spacing ;
  //=====================================================================
  private boolean RWING()
    {
      begin("RWING");
      if (!next('}')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  SEMI = ";" Spacing ;
  //=====================================================================
  private boolean SEMI()
    {
      begin("SEMI");
      if (!next(';')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  SL = "<<" !"=" Spacing ;
  //=====================================================================
  private boolean SL()
    {
      begin("SL");
      if (!next("<<")) return reject();
      if (!aheadNot('=')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  SLEQU = "<<=" Spacing ;
  //=====================================================================
  private boolean SLEQU()
    {
      begin("SLEQU");
      if (!next("<<=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  SR = ">>" ![=>] Spacing ;
  //=====================================================================
  private boolean SR()
    {
      begin("SR");
      if (!next(">>")) return reject();
      if (!aheadNotIn("=>")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  SREQU = ">>=" Spacing ;
  //=====================================================================
  private boolean SREQU()
    {
      begin("SREQU");
      if (!next(">>=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  STAR = "*" !"=" Spacing ;
  //=====================================================================
  private boolean STAR()
    {
      begin("STAR");
      if (!next('*')) return reject();
      if (!aheadNot('=')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  STAREQU = "*=" Spacing ;
  //=====================================================================
  private boolean STAREQU()
    {
      begin("STAREQU");
      if (!next("*=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  TILDA = "~" Spacing ;
  //=====================================================================
  private boolean TILDA()
    {
      begin("TILDA");
      if (!next('~')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  EOT = !_ ;
  //=====================================================================
  private boolean EOT()
    {
      begin("EOT");
      if (!aheadNot()) return reject();
      return accept();
    }
  
}
