//=========================================================================
//
//  This file was generated by Mouse 1.9 at 2017-06-26 07:55:24 GMT
//  from grammar '/Users/yuta/code/github/cpeg/test/Mouse/./Java.1.7.peg'.
//
//=========================================================================

import mouse.runtime.Source;

public class myParser_java17_M extends mouse.runtime.ParserMemo
{
  final mouse.runtime.SemanticsBase sem;
  
  //=======================================================================
  //
  //  Initialization
  //
  //=======================================================================
  //-------------------------------------------------------------------
  //  Constructor
  //-------------------------------------------------------------------
  public myParser_java17_M()
    {
      sem = new mouse.runtime.SemanticsBase();
      sem.rule = this;
      super.sem = sem;
      caches = cacheList;
    }
  
  //-------------------------------------------------------------------
  //  Run the parser
  //-------------------------------------------------------------------
  public boolean parse(Source src)
    {
      super.init(src);
      sem.init();
      boolean result = CompilationUnit();
      closeParser(result);
      return result;
    }
  
  //-------------------------------------------------------------------
  //  Get semantics
  //-------------------------------------------------------------------
  public mouse.runtime.SemanticsBase semantics()
    { return sem; }
  
  //=======================================================================
  //
  //  Parsing procedures
  //
  //=======================================================================
  //=====================================================================
  //  CompilationUnit = Spacing PackageDeclaration? ImportDeclaration*
  //    TypeDeclaration* EOT ;
  //=====================================================================
  private boolean CompilationUnit()
    {
      if (saved(CompilationUnit)) return reuse();
      Spacing();
      PackageDeclaration();
      while (ImportDeclaration());
      while (TypeDeclaration());
      if (!EOT()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  PackageDeclaration = Annotation* PACKAGE QualifiedIdentifier SEMI
  //    ;
  //=====================================================================
  private boolean PackageDeclaration()
    {
      if (saved(PackageDeclaration)) return reuse();
      while (Annotation());
      if (!PACKAGE()) return reject();
      if (!QualifiedIdentifier()) return reject();
      if (!SEMI()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ImportDeclaration = IMPORT STATIC? QualifiedIdentifier (DOT STAR)?
  //    SEMI / SEMI ;
  //=====================================================================
  private boolean ImportDeclaration()
    {
      if (saved(ImportDeclaration)) return reuse();
      if (ImportDeclaration_0()) return accept();
      if (SEMI()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  ImportDeclaration_0 = IMPORT STATIC? QualifiedIdentifier (DOT
  //    STAR)? SEMI
  //-------------------------------------------------------------------
  private boolean ImportDeclaration_0()
    {
      if (savedInner(ImportDeclaration_0)) return reuseInner();
      if (!IMPORT()) return rejectInner();
      STATIC();
      if (!QualifiedIdentifier()) return rejectInner();
      ImportDeclaration_1();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  ImportDeclaration_1 = DOT STAR
  //-------------------------------------------------------------------
  private boolean ImportDeclaration_1()
    {
      if (savedInner(ImportDeclaration_1)) return reuseInner();
      if (!DOT()) return rejectInner();
      if (!STAR()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  TypeDeclaration = Modifier* (ClassDeclaration / EnumDeclaration /
  //    InterfaceDeclaration / AnnotationTypeDeclaration) / SEMI ;
  //=====================================================================
  private boolean TypeDeclaration()
    {
      if (saved(TypeDeclaration)) return reuse();
      if (TypeDeclaration_0()) return accept();
      if (SEMI()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  TypeDeclaration_0 = Modifier* (ClassDeclaration / EnumDeclaration
  //    / InterfaceDeclaration / AnnotationTypeDeclaration)
  //-------------------------------------------------------------------
  private boolean TypeDeclaration_0()
    {
      if (savedInner(TypeDeclaration_0)) return reuseInner();
      while (Modifier());
      if (!ClassDeclaration()
       && !EnumDeclaration()
       && !InterfaceDeclaration()
       && !AnnotationTypeDeclaration()
         ) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ClassDeclaration = CLASS Identifier TypeParameters? (EXTENDS
  //    ClassType)? (IMPLEMENTS ClassTypeList)? ClassBody ;
  //=====================================================================
  private boolean ClassDeclaration()
    {
      if (saved(ClassDeclaration)) return reuse();
      if (!CLASS()) return reject();
      if (!Identifier()) return reject();
      TypeParameters();
      ClassDeclaration_0();
      ClassDeclaration_1();
      if (!ClassBody()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ClassDeclaration_0 = EXTENDS ClassType
  //-------------------------------------------------------------------
  private boolean ClassDeclaration_0()
    {
      if (savedInner(ClassDeclaration_0)) return reuseInner();
      if (!EXTENDS()) return rejectInner();
      if (!ClassType()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  ClassDeclaration_1 = IMPLEMENTS ClassTypeList
  //-------------------------------------------------------------------
  private boolean ClassDeclaration_1()
    {
      if (savedInner(ClassDeclaration_1)) return reuseInner();
      if (!IMPLEMENTS()) return rejectInner();
      if (!ClassTypeList()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ClassBody = LWING ClassBodyDeclaration* RWING ;
  //=====================================================================
  private boolean ClassBody()
    {
      if (saved(ClassBody)) return reuse();
      if (!LWING()) return reject();
      while (ClassBodyDeclaration());
      if (!RWING()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ClassBodyDeclaration = SEMI / STATIC? Block / Modifier* MemberDecl
  //    ;
  //=====================================================================
  private boolean ClassBodyDeclaration()
    {
      if (saved(ClassBodyDeclaration)) return reuse();
      if (SEMI()) return accept();
      if (ClassBodyDeclaration_0()) return accept();
      if (ClassBodyDeclaration_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  ClassBodyDeclaration_0 = STATIC? Block
  //-------------------------------------------------------------------
  private boolean ClassBodyDeclaration_0()
    {
      if (savedInner(ClassBodyDeclaration_0)) return reuseInner();
      STATIC();
      if (!Block()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  ClassBodyDeclaration_1 = Modifier* MemberDecl
  //-------------------------------------------------------------------
  private boolean ClassBodyDeclaration_1()
    {
      if (savedInner(ClassBodyDeclaration_1)) return reuseInner();
      while (Modifier());
      if (!MemberDecl()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  MemberDecl = TypeParameters GenericMethodOrConstructorRest / Type
  //    Identifier MethodDeclaratorRest / Type VariableDeclarators SEMI /
  //    VOID Identifier VoidMethodDeclaratorRest / Identifier
  //    ConstructorDeclaratorRest / InterfaceDeclaration /
  //    ClassDeclaration / EnumDeclaration / AnnotationTypeDeclaration ;
  //=====================================================================
  private boolean MemberDecl()
    {
      if (saved(MemberDecl)) return reuse();
      if (MemberDecl_0()) return accept();
      if (MemberDecl_1()) return accept();
      if (MemberDecl_2()) return accept();
      if (MemberDecl_3()) return accept();
      if (MemberDecl_4()) return accept();
      if (InterfaceDeclaration()) return accept();
      if (ClassDeclaration()) return accept();
      if (EnumDeclaration()) return accept();
      if (AnnotationTypeDeclaration()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  MemberDecl_0 = TypeParameters GenericMethodOrConstructorRest
  //-------------------------------------------------------------------
  private boolean MemberDecl_0()
    {
      if (savedInner(MemberDecl_0)) return reuseInner();
      if (!TypeParameters()) return rejectInner();
      if (!GenericMethodOrConstructorRest()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  MemberDecl_1 = Type Identifier MethodDeclaratorRest
  //-------------------------------------------------------------------
  private boolean MemberDecl_1()
    {
      if (savedInner(MemberDecl_1)) return reuseInner();
      if (!Type()) return rejectInner();
      if (!Identifier()) return rejectInner();
      if (!MethodDeclaratorRest()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  MemberDecl_2 = Type VariableDeclarators SEMI
  //-------------------------------------------------------------------
  private boolean MemberDecl_2()
    {
      if (savedInner(MemberDecl_2)) return reuseInner();
      if (!Type()) return rejectInner();
      if (!VariableDeclarators()) return rejectInner();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  MemberDecl_3 = VOID Identifier VoidMethodDeclaratorRest
  //-------------------------------------------------------------------
  private boolean MemberDecl_3()
    {
      if (savedInner(MemberDecl_3)) return reuseInner();
      if (!VOID()) return rejectInner();
      if (!Identifier()) return rejectInner();
      if (!VoidMethodDeclaratorRest()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  MemberDecl_4 = Identifier ConstructorDeclaratorRest
  //-------------------------------------------------------------------
  private boolean MemberDecl_4()
    {
      if (savedInner(MemberDecl_4)) return reuseInner();
      if (!Identifier()) return rejectInner();
      if (!ConstructorDeclaratorRest()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  GenericMethodOrConstructorRest = (Type / VOID) Identifier
  //    MethodDeclaratorRest / Identifier ConstructorDeclaratorRest ;
  //=====================================================================
  private boolean GenericMethodOrConstructorRest()
    {
      if (saved(GenericMethodOrConstructorRest)) return reuse();
      if (GenericMethodOrConstructorRest_0()) return accept();
      if (MemberDecl_4()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  GenericMethodOrConstructorRest_0 = (Type / VOID) Identifier
  //    MethodDeclaratorRest
  //-------------------------------------------------------------------
  private boolean GenericMethodOrConstructorRest_0()
    {
      if (savedInner(GenericMethodOrConstructorRest_0)) return reuseInner();
      if (!Type()
       && !VOID()
         ) return rejectInner();
      if (!Identifier()) return rejectInner();
      if (!MethodDeclaratorRest()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  MethodDeclaratorRest = FormalParameters Dim* (THROWS
  //    ClassTypeList)? (MethodBody / SEMI) ;
  //=====================================================================
  private boolean MethodDeclaratorRest()
    {
      if (saved(MethodDeclaratorRest)) return reuse();
      if (!FormalParameters()) return reject();
      while (Dim());
      MethodDeclaratorRest_0();
      if (!MethodBody()
       && !SEMI()
         ) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  MethodDeclaratorRest_0 = THROWS ClassTypeList
  //-------------------------------------------------------------------
  private boolean MethodDeclaratorRest_0()
    {
      if (savedInner(MethodDeclaratorRest_0)) return reuseInner();
      if (!THROWS()) return rejectInner();
      if (!ClassTypeList()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  VoidMethodDeclaratorRest = FormalParameters (THROWS ClassTypeList)?
  //    (MethodBody / SEMI) ;
  //=====================================================================
  private boolean VoidMethodDeclaratorRest()
    {
      if (saved(VoidMethodDeclaratorRest)) return reuse();
      if (!FormalParameters()) return reject();
      MethodDeclaratorRest_0();
      if (!MethodBody()
       && !SEMI()
         ) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ConstructorDeclaratorRest = FormalParameters (THROWS
  //    ClassTypeList)? MethodBody ;
  //=====================================================================
  private boolean ConstructorDeclaratorRest()
    {
      if (saved(ConstructorDeclaratorRest)) return reuse();
      if (!FormalParameters()) return reject();
      MethodDeclaratorRest_0();
      if (!MethodBody()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  MethodBody = Block ;
  //=====================================================================
  private boolean MethodBody()
    {
      if (saved(MethodBody)) return reuse();
      if (!Block()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  InterfaceDeclaration = INTERFACE Identifier TypeParameters?
  //    (EXTENDS ClassTypeList)? InterfaceBody ;
  //=====================================================================
  private boolean InterfaceDeclaration()
    {
      if (saved(InterfaceDeclaration)) return reuse();
      if (!INTERFACE()) return reject();
      if (!Identifier()) return reject();
      TypeParameters();
      InterfaceDeclaration_0();
      if (!InterfaceBody()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  InterfaceDeclaration_0 = EXTENDS ClassTypeList
  //-------------------------------------------------------------------
  private boolean InterfaceDeclaration_0()
    {
      if (savedInner(InterfaceDeclaration_0)) return reuseInner();
      if (!EXTENDS()) return rejectInner();
      if (!ClassTypeList()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  InterfaceBody = LWING InterfaceBodyDeclaration* RWING ;
  //=====================================================================
  private boolean InterfaceBody()
    {
      if (saved(InterfaceBody)) return reuse();
      if (!LWING()) return reject();
      while (InterfaceBodyDeclaration());
      if (!RWING()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  InterfaceBodyDeclaration = Modifier* InterfaceMemberDecl / SEMI ;
  //=====================================================================
  private boolean InterfaceBodyDeclaration()
    {
      if (saved(InterfaceBodyDeclaration)) return reuse();
      if (InterfaceBodyDeclaration_0()) return accept();
      if (SEMI()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  InterfaceBodyDeclaration_0 = Modifier* InterfaceMemberDecl
  //-------------------------------------------------------------------
  private boolean InterfaceBodyDeclaration_0()
    {
      if (savedInner(InterfaceBodyDeclaration_0)) return reuseInner();
      while (Modifier());
      if (!InterfaceMemberDecl()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  InterfaceMemberDecl = InterfaceMethodOrFieldDecl /
  //    InterfaceGenericMethodDecl / VOID Identifier
  //    VoidInterfaceMethodDeclaratorRest / InterfaceDeclaration /
  //    AnnotationTypeDeclaration / ClassDeclaration / EnumDeclaration ;
  //=====================================================================
  private boolean InterfaceMemberDecl()
    {
      if (saved(InterfaceMemberDecl)) return reuse();
      if (InterfaceMethodOrFieldDecl()) return accept();
      if (InterfaceGenericMethodDecl()) return accept();
      if (InterfaceMemberDecl_0()) return accept();
      if (InterfaceDeclaration()) return accept();
      if (AnnotationTypeDeclaration()) return accept();
      if (ClassDeclaration()) return accept();
      if (EnumDeclaration()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  InterfaceMemberDecl_0 = VOID Identifier
  //    VoidInterfaceMethodDeclaratorRest
  //-------------------------------------------------------------------
  private boolean InterfaceMemberDecl_0()
    {
      if (savedInner(InterfaceMemberDecl_0)) return reuseInner();
      if (!VOID()) return rejectInner();
      if (!Identifier()) return rejectInner();
      if (!VoidInterfaceMethodDeclaratorRest()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  InterfaceMethodOrFieldDecl = Type Identifier
  //    InterfaceMethodOrFieldRest ;
  //=====================================================================
  private boolean InterfaceMethodOrFieldDecl()
    {
      if (saved(InterfaceMethodOrFieldDecl)) return reuse();
      if (!Type()) return reject();
      if (!Identifier()) return reject();
      if (!InterfaceMethodOrFieldRest()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  InterfaceMethodOrFieldRest = ConstantDeclaratorsRest SEMI /
  //    InterfaceMethodDeclaratorRest ;
  //=====================================================================
  private boolean InterfaceMethodOrFieldRest()
    {
      if (saved(InterfaceMethodOrFieldRest)) return reuse();
      if (InterfaceMethodOrFieldRest_0()) return accept();
      if (InterfaceMethodDeclaratorRest()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  InterfaceMethodOrFieldRest_0 = ConstantDeclaratorsRest SEMI
  //-------------------------------------------------------------------
  private boolean InterfaceMethodOrFieldRest_0()
    {
      if (savedInner(InterfaceMethodOrFieldRest_0)) return reuseInner();
      if (!ConstantDeclaratorsRest()) return rejectInner();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  InterfaceMethodDeclaratorRest = FormalParameters Dim* (THROWS
  //    ClassTypeList)? SEMI ;
  //=====================================================================
  private boolean InterfaceMethodDeclaratorRest()
    {
      if (saved(InterfaceMethodDeclaratorRest)) return reuse();
      if (!FormalParameters()) return reject();
      while (Dim());
      MethodDeclaratorRest_0();
      if (!SEMI()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  InterfaceGenericMethodDecl = TypeParameters (Type / VOID)
  //    Identifier InterfaceMethodDeclaratorRest ;
  //=====================================================================
  private boolean InterfaceGenericMethodDecl()
    {
      if (saved(InterfaceGenericMethodDecl)) return reuse();
      if (!TypeParameters()) return reject();
      if (!Type()
       && !VOID()
         ) return reject();
      if (!Identifier()) return reject();
      if (!InterfaceMethodDeclaratorRest()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  VoidInterfaceMethodDeclaratorRest = FormalParameters (THROWS
  //    ClassTypeList)? SEMI ;
  //=====================================================================
  private boolean VoidInterfaceMethodDeclaratorRest()
    {
      if (saved(VoidInterfaceMethodDeclaratorRest)) return reuse();
      if (!FormalParameters()) return reject();
      MethodDeclaratorRest_0();
      if (!SEMI()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ConstantDeclaratorsRest = ConstantDeclaratorRest (COMMA
  //    ConstantDeclarator)* ;
  //=====================================================================
  private boolean ConstantDeclaratorsRest()
    {
      if (saved(ConstantDeclaratorsRest)) return reuse();
      if (!ConstantDeclaratorRest()) return reject();
      while (ConstantDeclaratorsRest_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ConstantDeclaratorsRest_0 = COMMA ConstantDeclarator
  //-------------------------------------------------------------------
  private boolean ConstantDeclaratorsRest_0()
    {
      if (savedInner(ConstantDeclaratorsRest_0)) return reuseInner();
      if (!COMMA()) return rejectInner();
      if (!ConstantDeclarator()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ConstantDeclarator = Identifier ConstantDeclaratorRest ;
  //=====================================================================
  private boolean ConstantDeclarator()
    {
      if (saved(ConstantDeclarator)) return reuse();
      if (!Identifier()) return reject();
      if (!ConstantDeclaratorRest()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ConstantDeclaratorRest = Dim* EQU VariableInitializer ;
  //=====================================================================
  private boolean ConstantDeclaratorRest()
    {
      if (saved(ConstantDeclaratorRest)) return reuse();
      while (Dim());
      if (!EQU()) return reject();
      if (!VariableInitializer()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  EnumDeclaration = ENUM Identifier (IMPLEMENTS ClassTypeList)?
  //    EnumBody ;
  //=====================================================================
  private boolean EnumDeclaration()
    {
      if (saved(EnumDeclaration)) return reuse();
      if (!ENUM()) return reject();
      if (!Identifier()) return reject();
      ClassDeclaration_1();
      if (!EnumBody()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  EnumBody = LWING EnumConstants? COMMA? EnumBodyDeclarations? RWING
  //    ;
  //=====================================================================
  private boolean EnumBody()
    {
      if (saved(EnumBody)) return reuse();
      if (!LWING()) return reject();
      EnumConstants();
      COMMA();
      EnumBodyDeclarations();
      if (!RWING()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  EnumConstants = EnumConstant (COMMA EnumConstant)* ;
  //=====================================================================
  private boolean EnumConstants()
    {
      if (saved(EnumConstants)) return reuse();
      if (!EnumConstant()) return reject();
      while (EnumConstants_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  EnumConstants_0 = COMMA EnumConstant
  //-------------------------------------------------------------------
  private boolean EnumConstants_0()
    {
      if (savedInner(EnumConstants_0)) return reuseInner();
      if (!COMMA()) return rejectInner();
      if (!EnumConstant()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  EnumConstant = Annotation* Identifier Arguments? ClassBody? ;
  //=====================================================================
  private boolean EnumConstant()
    {
      if (saved(EnumConstant)) return reuse();
      while (Annotation());
      if (!Identifier()) return reject();
      Arguments();
      ClassBody();
      return accept();
    }
  
  //=====================================================================
  //  EnumBodyDeclarations = SEMI ClassBodyDeclaration* ;
  //=====================================================================
  private boolean EnumBodyDeclarations()
    {
      if (saved(EnumBodyDeclarations)) return reuse();
      if (!SEMI()) return reject();
      while (ClassBodyDeclaration());
      return accept();
    }
  
  //=====================================================================
  //  LocalVariableDeclarationStatement = (FINAL / Annotation)* Type
  //    VariableDeclarators SEMI ;
  //=====================================================================
  private boolean LocalVariableDeclarationStatement()
    {
      if (saved(LocalVariableDeclarationStatement)) return reuse();
      while (LocalVariableDeclarationStatement_0());
      if (!Type()) return reject();
      if (!VariableDeclarators()) return reject();
      if (!SEMI()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  LocalVariableDeclarationStatement_0 = FINAL / Annotation
  //-------------------------------------------------------------------
  private boolean LocalVariableDeclarationStatement_0()
    {
      if (savedInner(LocalVariableDeclarationStatement_0)) return reuseInner();
      if (FINAL()) return acceptInner();
      if (Annotation()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  VariableDeclarators = VariableDeclarator (COMMA
  //    VariableDeclarator)* ;
  //=====================================================================
  private boolean VariableDeclarators()
    {
      if (saved(VariableDeclarators)) return reuse();
      if (!VariableDeclarator()) return reject();
      while (VariableDeclarators_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  VariableDeclarators_0 = COMMA VariableDeclarator
  //-------------------------------------------------------------------
  private boolean VariableDeclarators_0()
    {
      if (savedInner(VariableDeclarators_0)) return reuseInner();
      if (!COMMA()) return rejectInner();
      if (!VariableDeclarator()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  VariableDeclarator = Identifier Dim* (EQU VariableInitializer)? ;
  //=====================================================================
  private boolean VariableDeclarator()
    {
      if (saved(VariableDeclarator)) return reuse();
      if (!Identifier()) return reject();
      while (Dim());
      VariableDeclarator_0();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  VariableDeclarator_0 = EQU VariableInitializer
  //-------------------------------------------------------------------
  private boolean VariableDeclarator_0()
    {
      if (savedInner(VariableDeclarator_0)) return reuseInner();
      if (!EQU()) return rejectInner();
      if (!VariableInitializer()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  FormalParameters = LPAR FormalParameterList? RPAR ;
  //=====================================================================
  private boolean FormalParameters()
    {
      if (saved(FormalParameters)) return reuse();
      if (!LPAR()) return reject();
      FormalParameterList();
      if (!RPAR()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  FormalParameter = (FINAL / Annotation)* Type VariableDeclaratorId
  //    ;
  //=====================================================================
  private boolean FormalParameter()
    {
      if (saved(FormalParameter)) return reuse();
      while (LocalVariableDeclarationStatement_0());
      if (!Type()) return reject();
      if (!VariableDeclaratorId()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  LastFormalParameter = (FINAL / Annotation)* Type ELLIPSIS
  //    VariableDeclaratorId ;
  //=====================================================================
  private boolean LastFormalParameter()
    {
      if (saved(LastFormalParameter)) return reuse();
      while (LocalVariableDeclarationStatement_0());
      if (!Type()) return reject();
      if (!ELLIPSIS()) return reject();
      if (!VariableDeclaratorId()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  FormalParameterList = FormalParameter (COMMA FormalParameter)*
  //    (COMMA LastFormalParameter)? / LastFormalParameter ;
  //=====================================================================
  private boolean FormalParameterList()
    {
      if (saved(FormalParameterList)) return reuse();
      if (FormalParameterList_0()) return accept();
      if (LastFormalParameter()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  FormalParameterList_0 = FormalParameter (COMMA FormalParameter)*
  //    (COMMA LastFormalParameter)?
  //-------------------------------------------------------------------
  private boolean FormalParameterList_0()
    {
      if (savedInner(FormalParameterList_0)) return reuseInner();
      if (!FormalParameter()) return rejectInner();
      while (FormalParameterList_1());
      FormalParameterList_2();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  FormalParameterList_1 = COMMA FormalParameter
  //-------------------------------------------------------------------
  private boolean FormalParameterList_1()
    {
      if (savedInner(FormalParameterList_1)) return reuseInner();
      if (!COMMA()) return rejectInner();
      if (!FormalParameter()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  FormalParameterList_2 = COMMA LastFormalParameter
  //-------------------------------------------------------------------
  private boolean FormalParameterList_2()
    {
      if (savedInner(FormalParameterList_2)) return reuseInner();
      if (!COMMA()) return rejectInner();
      if (!LastFormalParameter()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  VariableDeclaratorId = Identifier Dim* ;
  //=====================================================================
  private boolean VariableDeclaratorId()
    {
      if (saved(VariableDeclaratorId)) return reuse();
      if (!Identifier()) return reject();
      while (Dim());
      return accept();
    }
  
  //=====================================================================
  //  Block = LWING BlockStatements RWING ;
  //=====================================================================
  private boolean Block()
    {
      if (saved(Block)) return reuse();
      if (!LWING()) return reject();
      BlockStatements();
      if (!RWING()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  BlockStatements = BlockStatement* ;
  //=====================================================================
  private boolean BlockStatements()
    {
      if (saved(BlockStatements)) return reuse();
      while (BlockStatement());
      return accept();
    }
  
  //=====================================================================
  //  BlockStatement = LocalVariableDeclarationStatement / Modifier*
  //    (ClassDeclaration / EnumDeclaration) / Statement ;
  //=====================================================================
  private boolean BlockStatement()
    {
      if (saved(BlockStatement)) return reuse();
      if (LocalVariableDeclarationStatement()) return accept();
      if (BlockStatement_0()) return accept();
      if (Statement()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  BlockStatement_0 = Modifier* (ClassDeclaration /
  //    EnumDeclaration)
  //-------------------------------------------------------------------
  private boolean BlockStatement_0()
    {
      if (savedInner(BlockStatement_0)) return reuseInner();
      while (Modifier());
      if (!ClassDeclaration()
       && !EnumDeclaration()
         ) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Statement = Block / ASSERT Expression (COLON Expression)? SEMI / IF
  //    ParExpression Statement (ELSE Statement)? / FOR LPAR ForInit?
  //    SEMI Expression? SEMI ForUpdate? RPAR Statement / FOR LPAR
  //    FormalParameter COLON Expression RPAR Statement / WHILE
  //    ParExpression Statement / DO Statement WHILE ParExpression SEMI /
  //    TRY LPAR Resource (SEMI Resource)* SEMI? RPAR Block Catch*
  //    Finally? / TRY Block (Catch+ Finally? / Finally) / SWITCH
  //    ParExpression LWING SwitchBlockStatementGroups RWING /
  //    SYNCHRONIZED ParExpression Block / RETURN Expression? SEMI /
  //    THROW Expression SEMI / BREAK Identifier? SEMI / CONTINUE
  //    Identifier? SEMI / SEMI / StatementExpression SEMI / Identifier
  //    COLON Statement ;
  //=====================================================================
  private boolean Statement()
    {
      if (saved(Statement)) return reuse();
      if (Block()) return accept();
      if (Statement_0()) return accept();
      if (Statement_1()) return accept();
      if (Statement_2()) return accept();
      if (Statement_3()) return accept();
      if (Statement_4()) return accept();
      if (Statement_5()) return accept();
      if (Statement_6()) return accept();
      if (Statement_7()) return accept();
      if (Statement_8()) return accept();
      if (Statement_9()) return accept();
      if (Statement_10()) return accept();
      if (Statement_11()) return accept();
      if (Statement_12()) return accept();
      if (Statement_13()) return accept();
      if (SEMI()) return accept();
      if (Statement_14()) return accept();
      if (Statement_15()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  Statement_0 = ASSERT Expression (COLON Expression)? SEMI
  //-------------------------------------------------------------------
  private boolean Statement_0()
    {
      if (savedInner(Statement_0)) return reuseInner();
      if (!ASSERT()) return rejectInner();
      if (!Expression()) return rejectInner();
      Statement_16();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_1 = IF ParExpression Statement (ELSE Statement)?
  //-------------------------------------------------------------------
  private boolean Statement_1()
    {
      if (savedInner(Statement_1)) return reuseInner();
      if (!IF()) return rejectInner();
      if (!ParExpression()) return rejectInner();
      if (!Statement()) return rejectInner();
      Statement_17();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_2 = FOR LPAR ForInit? SEMI Expression? SEMI ForUpdate?
  //    RPAR Statement
  //-------------------------------------------------------------------
  private boolean Statement_2()
    {
      if (savedInner(Statement_2)) return reuseInner();
      if (!FOR()) return rejectInner();
      if (!LPAR()) return rejectInner();
      ForInit();
      if (!SEMI()) return rejectInner();
      Expression();
      if (!SEMI()) return rejectInner();
      ForUpdate();
      if (!RPAR()) return rejectInner();
      if (!Statement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_3 = FOR LPAR FormalParameter COLON Expression RPAR
  //    Statement
  //-------------------------------------------------------------------
  private boolean Statement_3()
    {
      if (savedInner(Statement_3)) return reuseInner();
      if (!FOR()) return rejectInner();
      if (!LPAR()) return rejectInner();
      if (!FormalParameter()) return rejectInner();
      if (!COLON()) return rejectInner();
      if (!Expression()) return rejectInner();
      if (!RPAR()) return rejectInner();
      if (!Statement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_4 = WHILE ParExpression Statement
  //-------------------------------------------------------------------
  private boolean Statement_4()
    {
      if (savedInner(Statement_4)) return reuseInner();
      if (!WHILE()) return rejectInner();
      if (!ParExpression()) return rejectInner();
      if (!Statement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_5 = DO Statement WHILE ParExpression SEMI
  //-------------------------------------------------------------------
  private boolean Statement_5()
    {
      if (savedInner(Statement_5)) return reuseInner();
      if (!DO()) return rejectInner();
      if (!Statement()) return rejectInner();
      if (!WHILE()) return rejectInner();
      if (!ParExpression()) return rejectInner();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_6 = TRY LPAR Resource (SEMI Resource)* SEMI? RPAR Block
  //    Catch* Finally?
  //-------------------------------------------------------------------
  private boolean Statement_6()
    {
      if (savedInner(Statement_6)) return reuseInner();
      if (!TRY()) return rejectInner();
      if (!LPAR()) return rejectInner();
      if (!Resource()) return rejectInner();
      while (Statement_18());
      SEMI();
      if (!RPAR()) return rejectInner();
      if (!Block()) return rejectInner();
      while (Catch());
      Finally();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_7 = TRY Block (Catch+ Finally? / Finally)
  //-------------------------------------------------------------------
  private boolean Statement_7()
    {
      if (savedInner(Statement_7)) return reuseInner();
      if (!TRY()) return rejectInner();
      if (!Block()) return rejectInner();
      if (!Statement_19()
       && !Finally()
         ) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_8 = SWITCH ParExpression LWING
  //    SwitchBlockStatementGroups RWING
  //-------------------------------------------------------------------
  private boolean Statement_8()
    {
      if (savedInner(Statement_8)) return reuseInner();
      if (!SWITCH()) return rejectInner();
      if (!ParExpression()) return rejectInner();
      if (!LWING()) return rejectInner();
      SwitchBlockStatementGroups();
      if (!RWING()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_9 = SYNCHRONIZED ParExpression Block
  //-------------------------------------------------------------------
  private boolean Statement_9()
    {
      if (savedInner(Statement_9)) return reuseInner();
      if (!SYNCHRONIZED()) return rejectInner();
      if (!ParExpression()) return rejectInner();
      if (!Block()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_10 = RETURN Expression? SEMI
  //-------------------------------------------------------------------
  private boolean Statement_10()
    {
      if (savedInner(Statement_10)) return reuseInner();
      if (!RETURN()) return rejectInner();
      Expression();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_11 = THROW Expression SEMI
  //-------------------------------------------------------------------
  private boolean Statement_11()
    {
      if (savedInner(Statement_11)) return reuseInner();
      if (!THROW()) return rejectInner();
      if (!Expression()) return rejectInner();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_12 = BREAK Identifier? SEMI
  //-------------------------------------------------------------------
  private boolean Statement_12()
    {
      if (savedInner(Statement_12)) return reuseInner();
      if (!BREAK()) return rejectInner();
      Identifier();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_13 = CONTINUE Identifier? SEMI
  //-------------------------------------------------------------------
  private boolean Statement_13()
    {
      if (savedInner(Statement_13)) return reuseInner();
      if (!CONTINUE()) return rejectInner();
      Identifier();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_14 = StatementExpression SEMI
  //-------------------------------------------------------------------
  private boolean Statement_14()
    {
      if (savedInner(Statement_14)) return reuseInner();
      if (!StatementExpression()) return rejectInner();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_15 = Identifier COLON Statement
  //-------------------------------------------------------------------
  private boolean Statement_15()
    {
      if (savedInner(Statement_15)) return reuseInner();
      if (!Identifier()) return rejectInner();
      if (!COLON()) return rejectInner();
      if (!Statement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_16 = COLON Expression
  //-------------------------------------------------------------------
  private boolean Statement_16()
    {
      if (savedInner(Statement_16)) return reuseInner();
      if (!COLON()) return rejectInner();
      if (!Expression()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_17 = ELSE Statement
  //-------------------------------------------------------------------
  private boolean Statement_17()
    {
      if (savedInner(Statement_17)) return reuseInner();
      if (!ELSE()) return rejectInner();
      if (!Statement()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_18 = SEMI Resource
  //-------------------------------------------------------------------
  private boolean Statement_18()
    {
      if (savedInner(Statement_18)) return reuseInner();
      if (!SEMI()) return rejectInner();
      if (!Resource()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Statement_19 = Catch+ Finally?
  //-------------------------------------------------------------------
  private boolean Statement_19()
    {
      if (savedInner(Statement_19)) return reuseInner();
      if (!Catch()) return rejectInner();
      while (Catch());
      Finally();
      return acceptInner();
    }
  
  //=====================================================================
  //  Resource = (FINAL / Annotation)* Type VariableDeclaratorId EQU
  //    Expression ;
  //=====================================================================
  private boolean Resource()
    {
      if (saved(Resource)) return reuse();
      while (LocalVariableDeclarationStatement_0());
      if (!Type()) return reject();
      if (!VariableDeclaratorId()) return reject();
      if (!EQU()) return reject();
      if (!Expression()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Catch = CATCH LPAR (FINAL / Annotation)* Type (OR Type)*
  //    VariableDeclaratorId RPAR Block ;
  //=====================================================================
  private boolean Catch()
    {
      if (saved(Catch)) return reuse();
      if (!CATCH()) return reject();
      if (!LPAR()) return reject();
      while (LocalVariableDeclarationStatement_0());
      if (!Type()) return reject();
      while (Catch_0());
      if (!VariableDeclaratorId()) return reject();
      if (!RPAR()) return reject();
      if (!Block()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Catch_0 = OR Type
  //-------------------------------------------------------------------
  private boolean Catch_0()
    {
      if (savedInner(Catch_0)) return reuseInner();
      if (!OR()) return rejectInner();
      if (!Type()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Finally = FINALLY Block ;
  //=====================================================================
  private boolean Finally()
    {
      if (saved(Finally)) return reuse();
      if (!FINALLY()) return reject();
      if (!Block()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  SwitchBlockStatementGroups = SwitchBlockStatementGroup* ;
  //=====================================================================
  private boolean SwitchBlockStatementGroups()
    {
      if (saved(SwitchBlockStatementGroups)) return reuse();
      while (SwitchBlockStatementGroup());
      return accept();
    }
  
  //=====================================================================
  //  SwitchBlockStatementGroup = SwitchLabel BlockStatements ;
  //=====================================================================
  private boolean SwitchBlockStatementGroup()
    {
      if (saved(SwitchBlockStatementGroup)) return reuse();
      if (!SwitchLabel()) return reject();
      BlockStatements();
      return accept();
    }
  
  //=====================================================================
  //  SwitchLabel = CASE ConstantExpression COLON / CASE EnumConstantName
  //    COLON / DEFAULT COLON ;
  //=====================================================================
  private boolean SwitchLabel()
    {
      if (saved(SwitchLabel)) return reuse();
      if (SwitchLabel_0()) return accept();
      if (SwitchLabel_1()) return accept();
      if (SwitchLabel_2()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  SwitchLabel_0 = CASE ConstantExpression COLON
  //-------------------------------------------------------------------
  private boolean SwitchLabel_0()
    {
      if (savedInner(SwitchLabel_0)) return reuseInner();
      if (!CASE()) return rejectInner();
      if (!ConstantExpression()) return rejectInner();
      if (!COLON()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  SwitchLabel_1 = CASE EnumConstantName COLON
  //-------------------------------------------------------------------
  private boolean SwitchLabel_1()
    {
      if (savedInner(SwitchLabel_1)) return reuseInner();
      if (!CASE()) return rejectInner();
      if (!EnumConstantName()) return rejectInner();
      if (!COLON()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  SwitchLabel_2 = DEFAULT COLON
  //-------------------------------------------------------------------
  private boolean SwitchLabel_2()
    {
      if (savedInner(SwitchLabel_2)) return reuseInner();
      if (!DEFAULT()) return rejectInner();
      if (!COLON()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ForInit = (FINAL / Annotation)* Type VariableDeclarators /
  //    StatementExpression (COMMA StatementExpression)* ;
  //=====================================================================
  private boolean ForInit()
    {
      if (saved(ForInit)) return reuse();
      if (ForInit_0()) return accept();
      if (ForInit_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  ForInit_0 = (FINAL / Annotation)* Type VariableDeclarators
  //-------------------------------------------------------------------
  private boolean ForInit_0()
    {
      if (savedInner(ForInit_0)) return reuseInner();
      while (LocalVariableDeclarationStatement_0());
      if (!Type()) return rejectInner();
      if (!VariableDeclarators()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  ForInit_1 = StatementExpression (COMMA StatementExpression)*
  //-------------------------------------------------------------------
  private boolean ForInit_1()
    {
      if (savedInner(ForInit_1)) return reuseInner();
      if (!StatementExpression()) return rejectInner();
      while (ForInit_2());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  ForInit_2 = COMMA StatementExpression
  //-------------------------------------------------------------------
  private boolean ForInit_2()
    {
      if (savedInner(ForInit_2)) return reuseInner();
      if (!COMMA()) return rejectInner();
      if (!StatementExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ForUpdate = StatementExpression (COMMA StatementExpression)* ;
  //=====================================================================
  private boolean ForUpdate()
    {
      if (saved(ForUpdate)) return reuse();
      if (!StatementExpression()) return reject();
      while (ForInit_2());
      return accept();
    }
  
  //=====================================================================
  //  EnumConstantName = Identifier ;
  //=====================================================================
  private boolean EnumConstantName()
    {
      if (saved(EnumConstantName)) return reuse();
      if (!Identifier()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  StatementExpression = Expression ;
  //=====================================================================
  private boolean StatementExpression()
    {
      if (saved(StatementExpression)) return reuse();
      if (!Expression()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ConstantExpression = Expression ;
  //=====================================================================
  private boolean ConstantExpression()
    {
      if (saved(ConstantExpression)) return reuse();
      if (!Expression()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Expression = ConditionalExpression (AssignmentOperator
  //    ConditionalExpression)* ;
  //=====================================================================
  private boolean Expression()
    {
      if (saved(Expression)) return reuse();
      if (!ConditionalExpression()) return reject();
      while (Expression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Expression_0 = AssignmentOperator ConditionalExpression
  //-------------------------------------------------------------------
  private boolean Expression_0()
    {
      if (savedInner(Expression_0)) return reuseInner();
      if (!AssignmentOperator()) return rejectInner();
      if (!ConditionalExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  AssignmentOperator = EQU / PLUSEQU / MINUSEQU / STAREQU / DIVEQU /
  //    ANDEQU / OREQU / HATEQU / MODEQU / SLEQU / SREQU / BSREQU ;
  //=====================================================================
  private boolean AssignmentOperator()
    {
      if (saved(AssignmentOperator)) return reuse();
      if (EQU()) return accept();
      if (PLUSEQU()) return accept();
      if (MINUSEQU()) return accept();
      if (STAREQU()) return accept();
      if (DIVEQU()) return accept();
      if (ANDEQU()) return accept();
      if (OREQU()) return accept();
      if (HATEQU()) return accept();
      if (MODEQU()) return accept();
      if (SLEQU()) return accept();
      if (SREQU()) return accept();
      if (BSREQU()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  ConditionalExpression = ConditionalOrExpression (QUERY Expression
  //    COLON ConditionalOrExpression)* ;
  //=====================================================================
  private boolean ConditionalExpression()
    {
      if (saved(ConditionalExpression)) return reuse();
      if (!ConditionalOrExpression()) return reject();
      while (ConditionalExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ConditionalExpression_0 = QUERY Expression COLON
  //    ConditionalOrExpression
  //-------------------------------------------------------------------
  private boolean ConditionalExpression_0()
    {
      if (savedInner(ConditionalExpression_0)) return reuseInner();
      if (!QUERY()) return rejectInner();
      if (!Expression()) return rejectInner();
      if (!COLON()) return rejectInner();
      if (!ConditionalOrExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ConditionalOrExpression = ConditionalAndExpression (OROR
  //    ConditionalAndExpression)* ;
  //=====================================================================
  private boolean ConditionalOrExpression()
    {
      if (saved(ConditionalOrExpression)) return reuse();
      if (!ConditionalAndExpression()) return reject();
      while (ConditionalOrExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ConditionalOrExpression_0 = OROR ConditionalAndExpression
  //-------------------------------------------------------------------
  private boolean ConditionalOrExpression_0()
    {
      if (savedInner(ConditionalOrExpression_0)) return reuseInner();
      if (!OROR()) return rejectInner();
      if (!ConditionalAndExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ConditionalAndExpression = InclusiveOrExpression (ANDAND
  //    InclusiveOrExpression)* ;
  //=====================================================================
  private boolean ConditionalAndExpression()
    {
      if (saved(ConditionalAndExpression)) return reuse();
      if (!InclusiveOrExpression()) return reject();
      while (ConditionalAndExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ConditionalAndExpression_0 = ANDAND InclusiveOrExpression
  //-------------------------------------------------------------------
  private boolean ConditionalAndExpression_0()
    {
      if (savedInner(ConditionalAndExpression_0)) return reuseInner();
      if (!ANDAND()) return rejectInner();
      if (!InclusiveOrExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  InclusiveOrExpression = ExclusiveOrExpression (OR
  //    ExclusiveOrExpression)* ;
  //=====================================================================
  private boolean InclusiveOrExpression()
    {
      if (saved(InclusiveOrExpression)) return reuse();
      if (!ExclusiveOrExpression()) return reject();
      while (InclusiveOrExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  InclusiveOrExpression_0 = OR ExclusiveOrExpression
  //-------------------------------------------------------------------
  private boolean InclusiveOrExpression_0()
    {
      if (savedInner(InclusiveOrExpression_0)) return reuseInner();
      if (!OR()) return rejectInner();
      if (!ExclusiveOrExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ExclusiveOrExpression = AndExpression (HAT AndExpression)* ;
  //=====================================================================
  private boolean ExclusiveOrExpression()
    {
      if (saved(ExclusiveOrExpression)) return reuse();
      if (!AndExpression()) return reject();
      while (ExclusiveOrExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ExclusiveOrExpression_0 = HAT AndExpression
  //-------------------------------------------------------------------
  private boolean ExclusiveOrExpression_0()
    {
      if (savedInner(ExclusiveOrExpression_0)) return reuseInner();
      if (!HAT()) return rejectInner();
      if (!AndExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  AndExpression = EqualityExpression (AND EqualityExpression)* ;
  //=====================================================================
  private boolean AndExpression()
    {
      if (saved(AndExpression)) return reuse();
      if (!EqualityExpression()) return reject();
      while (AndExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  AndExpression_0 = AND EqualityExpression
  //-------------------------------------------------------------------
  private boolean AndExpression_0()
    {
      if (savedInner(AndExpression_0)) return reuseInner();
      if (!AND()) return rejectInner();
      if (!EqualityExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  EqualityExpression = RelationalExpression ((EQUAL / NOTEQUAL)
  //    RelationalExpression)* ;
  //=====================================================================
  private boolean EqualityExpression()
    {
      if (saved(EqualityExpression)) return reuse();
      if (!RelationalExpression()) return reject();
      while (EqualityExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  EqualityExpression_0 = (EQUAL / NOTEQUAL) RelationalExpression
  //-------------------------------------------------------------------
  private boolean EqualityExpression_0()
    {
      if (savedInner(EqualityExpression_0)) return reuseInner();
      if (!EQUAL()
       && !NOTEQUAL()
         ) return rejectInner();
      if (!RelationalExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  RelationalExpression = ShiftExpression ((LE / GE / LT / GT)
  //    ShiftExpression / INSTANCEOF ReferenceType)* ;
  //=====================================================================
  private boolean RelationalExpression()
    {
      if (saved(RelationalExpression)) return reuse();
      if (!ShiftExpression()) return reject();
      while (RelationalExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  RelationalExpression_0 = (LE / GE / LT / GT) ShiftExpression /
  //    INSTANCEOF ReferenceType
  //-------------------------------------------------------------------
  private boolean RelationalExpression_0()
    {
      if (savedInner(RelationalExpression_0)) return reuseInner();
      if (RelationalExpression_1()) return acceptInner();
      if (RelationalExpression_2()) return acceptInner();
      return rejectInner();
    }
  
  //-------------------------------------------------------------------
  //  RelationalExpression_1 = (LE / GE / LT / GT) ShiftExpression
  //-------------------------------------------------------------------
  private boolean RelationalExpression_1()
    {
      if (savedInner(RelationalExpression_1)) return reuseInner();
      if (!LE()
       && !GE()
       && !LT()
       && !GT()
         ) return rejectInner();
      if (!ShiftExpression()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  RelationalExpression_2 = INSTANCEOF ReferenceType
  //-------------------------------------------------------------------
  private boolean RelationalExpression_2()
    {
      if (savedInner(RelationalExpression_2)) return reuseInner();
      if (!INSTANCEOF()) return rejectInner();
      if (!ReferenceType()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ShiftExpression = AdditiveExpression ((SL / SR / BSR)
  //    AdditiveExpression)* ;
  //=====================================================================
  private boolean ShiftExpression()
    {
      if (saved(ShiftExpression)) return reuse();
      if (!AdditiveExpression()) return reject();
      while (ShiftExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ShiftExpression_0 = (SL / SR / BSR) AdditiveExpression
  //-------------------------------------------------------------------
  private boolean ShiftExpression_0()
    {
      if (savedInner(ShiftExpression_0)) return reuseInner();
      if (!SL()
       && !SR()
       && !BSR()
         ) return rejectInner();
      if (!AdditiveExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  AdditiveExpression = MultiplicativeExpression ((PLUS / MINUS)
  //    MultiplicativeExpression)* ;
  //=====================================================================
  private boolean AdditiveExpression()
    {
      if (saved(AdditiveExpression)) return reuse();
      if (!MultiplicativeExpression()) return reject();
      while (AdditiveExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  AdditiveExpression_0 = (PLUS / MINUS) MultiplicativeExpression
  //-------------------------------------------------------------------
  private boolean AdditiveExpression_0()
    {
      if (savedInner(AdditiveExpression_0)) return reuseInner();
      if (!PLUS()
       && !MINUS()
         ) return rejectInner();
      if (!MultiplicativeExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  MultiplicativeExpression = UnaryExpression ((STAR / DIV / MOD)
  //    UnaryExpression)* ;
  //=====================================================================
  private boolean MultiplicativeExpression()
    {
      if (saved(MultiplicativeExpression)) return reuse();
      if (!UnaryExpression()) return reject();
      while (MultiplicativeExpression_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  MultiplicativeExpression_0 = (STAR / DIV / MOD) UnaryExpression
  //-------------------------------------------------------------------
  private boolean MultiplicativeExpression_0()
    {
      if (savedInner(MultiplicativeExpression_0)) return reuseInner();
      if (!STAR()
       && !DIV()
       && !MOD()
         ) return rejectInner();
      if (!UnaryExpression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  UnaryExpression = PrefixOp UnaryExpression / LPAR Type RPAR
  //    UnaryExpression / Primary Selector* PostfixOp* ;
  //=====================================================================
  private boolean UnaryExpression()
    {
      if (saved(UnaryExpression)) return reuse();
      if (UnaryExpression_0()) return accept();
      if (UnaryExpression_1()) return accept();
      if (UnaryExpression_2()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  UnaryExpression_0 = PrefixOp UnaryExpression
  //-------------------------------------------------------------------
  private boolean UnaryExpression_0()
    {
      if (savedInner(UnaryExpression_0)) return reuseInner();
      if (!PrefixOp()) return rejectInner();
      if (!UnaryExpression()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  UnaryExpression_1 = LPAR Type RPAR UnaryExpression
  //-------------------------------------------------------------------
  private boolean UnaryExpression_1()
    {
      if (savedInner(UnaryExpression_1)) return reuseInner();
      if (!LPAR()) return rejectInner();
      if (!Type()) return rejectInner();
      if (!RPAR()) return rejectInner();
      if (!UnaryExpression()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  UnaryExpression_2 = Primary Selector* PostfixOp*
  //-------------------------------------------------------------------
  private boolean UnaryExpression_2()
    {
      if (savedInner(UnaryExpression_2)) return reuseInner();
      if (!Primary()) return rejectInner();
      while (Selector());
      while (PostfixOp());
      return acceptInner();
    }
  
  //=====================================================================
  //  Primary = ParExpression / NonWildcardTypeArguments
  //    (ExplicitGenericInvocationSuffix / THIS Arguments) / THIS
  //    Arguments? / SUPER SuperSuffix / Literal / NEW Creator /
  //    QualifiedIdentifier IdentifierSuffix? / BasicType Dim* DOT CLASS
  //    / VOID DOT CLASS ;
  //=====================================================================
  private boolean Primary()
    {
      if (saved(Primary)) return reuse();
      if (ParExpression()) return accept();
      if (Primary_0()) return accept();
      if (Primary_1()) return accept();
      if (Primary_2()) return accept();
      if (Literal()) return accept();
      if (Primary_3()) return accept();
      if (Primary_4()) return accept();
      if (Primary_5()) return accept();
      if (Primary_6()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  Primary_0 = NonWildcardTypeArguments
  //    (ExplicitGenericInvocationSuffix / THIS Arguments)
  //-------------------------------------------------------------------
  private boolean Primary_0()
    {
      if (savedInner(Primary_0)) return reuseInner();
      if (!NonWildcardTypeArguments()) return rejectInner();
      if (!ExplicitGenericInvocationSuffix()
       && !Primary_7()
         ) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Primary_1 = THIS Arguments?
  //-------------------------------------------------------------------
  private boolean Primary_1()
    {
      if (savedInner(Primary_1)) return reuseInner();
      if (!THIS()) return rejectInner();
      Arguments();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Primary_2 = SUPER SuperSuffix
  //-------------------------------------------------------------------
  private boolean Primary_2()
    {
      if (savedInner(Primary_2)) return reuseInner();
      if (!SUPER()) return rejectInner();
      if (!SuperSuffix()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Primary_3 = NEW Creator
  //-------------------------------------------------------------------
  private boolean Primary_3()
    {
      if (savedInner(Primary_3)) return reuseInner();
      if (!NEW()) return rejectInner();
      if (!Creator()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Primary_4 = QualifiedIdentifier IdentifierSuffix?
  //-------------------------------------------------------------------
  private boolean Primary_4()
    {
      if (savedInner(Primary_4)) return reuseInner();
      if (!QualifiedIdentifier()) return rejectInner();
      IdentifierSuffix();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Primary_5 = BasicType Dim* DOT CLASS
  //-------------------------------------------------------------------
  private boolean Primary_5()
    {
      if (savedInner(Primary_5)) return reuseInner();
      if (!BasicType()) return rejectInner();
      while (Dim());
      if (!DOT()) return rejectInner();
      if (!CLASS()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Primary_6 = VOID DOT CLASS
  //-------------------------------------------------------------------
  private boolean Primary_6()
    {
      if (savedInner(Primary_6)) return reuseInner();
      if (!VOID()) return rejectInner();
      if (!DOT()) return rejectInner();
      if (!CLASS()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Primary_7 = THIS Arguments
  //-------------------------------------------------------------------
  private boolean Primary_7()
    {
      if (savedInner(Primary_7)) return reuseInner();
      if (!THIS()) return rejectInner();
      if (!Arguments()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  IdentifierSuffix = LBRK (RBRK Dim* DOT CLASS / Expression RBRK) /
  //    Arguments / DOT (CLASS / ExplicitGenericInvocation / THIS / SUPER
  //    Arguments / NEW NonWildcardTypeArguments? InnerCreator) ;
  //=====================================================================
  private boolean IdentifierSuffix()
    {
      if (saved(IdentifierSuffix)) return reuse();
      if (IdentifierSuffix_0()) return accept();
      if (Arguments()) return accept();
      if (IdentifierSuffix_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  IdentifierSuffix_0 = LBRK (RBRK Dim* DOT CLASS / Expression
  //    RBRK)
  //-------------------------------------------------------------------
  private boolean IdentifierSuffix_0()
    {
      if (savedInner(IdentifierSuffix_0)) return reuseInner();
      if (!LBRK()) return rejectInner();
      if (!IdentifierSuffix_2()
       && !IdentifierSuffix_3()
         ) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  IdentifierSuffix_1 = DOT (CLASS / ExplicitGenericInvocation /
  //    THIS / SUPER Arguments / NEW NonWildcardTypeArguments?
  //    InnerCreator)
  //-------------------------------------------------------------------
  private boolean IdentifierSuffix_1()
    {
      if (savedInner(IdentifierSuffix_1)) return reuseInner();
      if (!DOT()) return rejectInner();
      if (!CLASS()
       && !ExplicitGenericInvocation()
       && !THIS()
       && !IdentifierSuffix_4()
       && !IdentifierSuffix_5()
         ) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  IdentifierSuffix_2 = RBRK Dim* DOT CLASS
  //-------------------------------------------------------------------
  private boolean IdentifierSuffix_2()
    {
      if (savedInner(IdentifierSuffix_2)) return reuseInner();
      if (!RBRK()) return rejectInner();
      while (Dim());
      if (!DOT()) return rejectInner();
      if (!CLASS()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  IdentifierSuffix_3 = Expression RBRK
  //-------------------------------------------------------------------
  private boolean IdentifierSuffix_3()
    {
      if (savedInner(IdentifierSuffix_3)) return reuseInner();
      if (!Expression()) return rejectInner();
      if (!RBRK()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  IdentifierSuffix_4 = SUPER Arguments
  //-------------------------------------------------------------------
  private boolean IdentifierSuffix_4()
    {
      if (savedInner(IdentifierSuffix_4)) return reuseInner();
      if (!SUPER()) return rejectInner();
      if (!Arguments()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  IdentifierSuffix_5 = NEW NonWildcardTypeArguments? InnerCreator
  //-------------------------------------------------------------------
  private boolean IdentifierSuffix_5()
    {
      if (savedInner(IdentifierSuffix_5)) return reuseInner();
      if (!NEW()) return rejectInner();
      NonWildcardTypeArguments();
      if (!InnerCreator()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ExplicitGenericInvocation = NonWildcardTypeArguments
  //    ExplicitGenericInvocationSuffix ;
  //=====================================================================
  private boolean ExplicitGenericInvocation()
    {
      if (saved(ExplicitGenericInvocation)) return reuse();
      if (!NonWildcardTypeArguments()) return reject();
      if (!ExplicitGenericInvocationSuffix()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  NonWildcardTypeArguments = LPOINT ReferenceType (COMMA
  //    ReferenceType)* RPOINT ;
  //=====================================================================
  private boolean NonWildcardTypeArguments()
    {
      if (saved(NonWildcardTypeArguments)) return reuse();
      if (!LPOINT()) return reject();
      if (!ReferenceType()) return reject();
      while (NonWildcardTypeArguments_0());
      if (!RPOINT()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  NonWildcardTypeArguments_0 = COMMA ReferenceType
  //-------------------------------------------------------------------
  private boolean NonWildcardTypeArguments_0()
    {
      if (savedInner(NonWildcardTypeArguments_0)) return reuseInner();
      if (!COMMA()) return rejectInner();
      if (!ReferenceType()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  TypeArgumentsOrDiamond = LPOINT RPOINT / TypeArguments ;
  //=====================================================================
  private boolean TypeArgumentsOrDiamond()
    {
      if (saved(TypeArgumentsOrDiamond)) return reuse();
      if (TypeArgumentsOrDiamond_0()) return accept();
      if (TypeArguments()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  TypeArgumentsOrDiamond_0 = LPOINT RPOINT
  //-------------------------------------------------------------------
  private boolean TypeArgumentsOrDiamond_0()
    {
      if (savedInner(TypeArgumentsOrDiamond_0)) return reuseInner();
      if (!LPOINT()) return rejectInner();
      if (!RPOINT()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  NonWildcardTypeArgumentsOrDiamond = LPOINT RPOINT /
  //    NonWildcardTypeArguments ;
  //=====================================================================
  private boolean NonWildcardTypeArgumentsOrDiamond()
    {
      if (saved(NonWildcardTypeArgumentsOrDiamond)) return reuse();
      if (TypeArgumentsOrDiamond_0()) return accept();
      if (NonWildcardTypeArguments()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  ExplicitGenericInvocationSuffix = SUPER SuperSuffix / Identifier
  //    Arguments ;
  //=====================================================================
  private boolean ExplicitGenericInvocationSuffix()
    {
      if (saved(ExplicitGenericInvocationSuffix)) return reuse();
      if (Primary_2()) return accept();
      if (ExplicitGenericInvocationSuffix_0()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  ExplicitGenericInvocationSuffix_0 = Identifier Arguments
  //-------------------------------------------------------------------
  private boolean ExplicitGenericInvocationSuffix_0()
    {
      if (savedInner(ExplicitGenericInvocationSuffix_0)) return reuseInner();
      if (!Identifier()) return rejectInner();
      if (!Arguments()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  PrefixOp = INC / DEC / BANG / TILDA / PLUS / MINUS ;
  //=====================================================================
  private boolean PrefixOp()
    {
      if (saved(PrefixOp)) return reuse();
      if (INC()) return accept();
      if (DEC()) return accept();
      if (BANG()) return accept();
      if (TILDA()) return accept();
      if (PLUS()) return accept();
      if (MINUS()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  PostfixOp = INC / DEC ;
  //=====================================================================
  private boolean PostfixOp()
    {
      if (saved(PostfixOp)) return reuse();
      if (INC()) return accept();
      if (DEC()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Selector = DOT Identifier Arguments? / DOT
  //    ExplicitGenericInvocation / DOT THIS / DOT SUPER SuperSuffix /
  //    DOT NEW NonWildcardTypeArguments? InnerCreator / DimExpr ;
  //=====================================================================
  private boolean Selector()
    {
      if (saved(Selector)) return reuse();
      if (Selector_0()) return accept();
      if (Selector_1()) return accept();
      if (Selector_2()) return accept();
      if (Selector_3()) return accept();
      if (Selector_4()) return accept();
      if (DimExpr()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  Selector_0 = DOT Identifier Arguments?
  //-------------------------------------------------------------------
  private boolean Selector_0()
    {
      if (savedInner(Selector_0)) return reuseInner();
      if (!DOT()) return rejectInner();
      if (!Identifier()) return rejectInner();
      Arguments();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Selector_1 = DOT ExplicitGenericInvocation
  //-------------------------------------------------------------------
  private boolean Selector_1()
    {
      if (savedInner(Selector_1)) return reuseInner();
      if (!DOT()) return rejectInner();
      if (!ExplicitGenericInvocation()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Selector_2 = DOT THIS
  //-------------------------------------------------------------------
  private boolean Selector_2()
    {
      if (savedInner(Selector_2)) return reuseInner();
      if (!DOT()) return rejectInner();
      if (!THIS()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Selector_3 = DOT SUPER SuperSuffix
  //-------------------------------------------------------------------
  private boolean Selector_3()
    {
      if (savedInner(Selector_3)) return reuseInner();
      if (!DOT()) return rejectInner();
      if (!SUPER()) return rejectInner();
      if (!SuperSuffix()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Selector_4 = DOT NEW NonWildcardTypeArguments? InnerCreator
  //-------------------------------------------------------------------
  private boolean Selector_4()
    {
      if (savedInner(Selector_4)) return reuseInner();
      if (!DOT()) return rejectInner();
      if (!NEW()) return rejectInner();
      NonWildcardTypeArguments();
      if (!InnerCreator()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  SuperSuffix = Arguments / DOT NonWildcardTypeArguments? Identifier
  //    Arguments? ;
  //=====================================================================
  private boolean SuperSuffix()
    {
      if (saved(SuperSuffix)) return reuse();
      if (Arguments()) return accept();
      if (SuperSuffix_0()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  SuperSuffix_0 = DOT NonWildcardTypeArguments? Identifier
  //    Arguments?
  //-------------------------------------------------------------------
  private boolean SuperSuffix_0()
    {
      if (savedInner(SuperSuffix_0)) return reuseInner();
      if (!DOT()) return rejectInner();
      NonWildcardTypeArguments();
      if (!Identifier()) return rejectInner();
      Arguments();
      return acceptInner();
    }
  
  //=====================================================================
  //  BasicType = ("byte" / "short" / "char" / "int" / "long" / "float" /
  //    "double" / "boolean") !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean BasicType()
    {
      if (saved(BasicType)) return reuse();
      if (!next("byte")
       && !next("short")
       && !next("char")
       && !next("int")
       && !next("long")
       && !next("float")
       && !next("double")
       && !next("boolean")
         ) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  BasicType_0 = !LetterOrDigit
  //-------------------------------------------------------------------
  private boolean BasicType_0()
    {
      if (savedInner(BasicType_0)) return reusePred();
      if (LetterOrDigit()) return rejectPred();
      return acceptPred();
    }
  
  //=====================================================================
  //  Arguments = LPAR (Expression (COMMA Expression)*)? RPAR ;
  //=====================================================================
  private boolean Arguments()
    {
      if (saved(Arguments)) return reuse();
      if (!LPAR()) return reject();
      Arguments_0();
      if (!RPAR()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Arguments_0 = Expression (COMMA Expression)*
  //-------------------------------------------------------------------
  private boolean Arguments_0()
    {
      if (savedInner(Arguments_0)) return reuseInner();
      if (!Expression()) return rejectInner();
      while (Arguments_1());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Arguments_1 = COMMA Expression
  //-------------------------------------------------------------------
  private boolean Arguments_1()
    {
      if (savedInner(Arguments_1)) return reuseInner();
      if (!COMMA()) return rejectInner();
      if (!Expression()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Creator = (BasicType / CreatedName) ArrayCreatorRest /
  //    NonWildcardTypeArguments? CreatedName ClassCreatorRest ;
  //=====================================================================
  private boolean Creator()
    {
      if (saved(Creator)) return reuse();
      if (Creator_0()) return accept();
      if (Creator_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  Creator_0 = (BasicType / CreatedName) ArrayCreatorRest
  //-------------------------------------------------------------------
  private boolean Creator_0()
    {
      if (savedInner(Creator_0)) return reuseInner();
      if (!BasicType()
       && !CreatedName()
         ) return rejectInner();
      if (!ArrayCreatorRest()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Creator_1 = NonWildcardTypeArguments? CreatedName
  //    ClassCreatorRest
  //-------------------------------------------------------------------
  private boolean Creator_1()
    {
      if (savedInner(Creator_1)) return reuseInner();
      NonWildcardTypeArguments();
      if (!CreatedName()) return rejectInner();
      if (!ClassCreatorRest()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  CreatedName = Identifier TypeArgumentsOrDiamond? (DOT Identifier
  //    TypeArgumentsOrDiamond?)* ;
  //=====================================================================
  private boolean CreatedName()
    {
      if (saved(CreatedName)) return reuse();
      if (!Identifier()) return reject();
      TypeArgumentsOrDiamond();
      while (CreatedName_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  CreatedName_0 = DOT Identifier TypeArgumentsOrDiamond?
  //-------------------------------------------------------------------
  private boolean CreatedName_0()
    {
      if (savedInner(CreatedName_0)) return reuseInner();
      if (!DOT()) return rejectInner();
      if (!Identifier()) return rejectInner();
      TypeArgumentsOrDiamond();
      return acceptInner();
    }
  
  //=====================================================================
  //  InnerCreator = Identifier NonWildcardTypeArgumentsOrDiamond?
  //    ClassCreatorRest ;
  //=====================================================================
  private boolean InnerCreator()
    {
      if (saved(InnerCreator)) return reuse();
      if (!Identifier()) return reject();
      NonWildcardTypeArgumentsOrDiamond();
      if (!ClassCreatorRest()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ClassCreatorRest = Arguments ClassBody? ;
  //=====================================================================
  private boolean ClassCreatorRest()
    {
      if (saved(ClassCreatorRest)) return reuse();
      if (!Arguments()) return reject();
      ClassBody();
      return accept();
    }
  
  //=====================================================================
  //  ArrayCreatorRest = Dim+ ArrayInitializer / DimExpr+ Dim* / Dim ;
  //=====================================================================
  private boolean ArrayCreatorRest()
    {
      if (saved(ArrayCreatorRest)) return reuse();
      if (ArrayCreatorRest_0()) return accept();
      if (ArrayCreatorRest_1()) return accept();
      if (Dim()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  ArrayCreatorRest_0 = Dim+ ArrayInitializer
  //-------------------------------------------------------------------
  private boolean ArrayCreatorRest_0()
    {
      if (savedInner(ArrayCreatorRest_0)) return reuseInner();
      if (!Dim()) return rejectInner();
      while (Dim());
      if (!ArrayInitializer()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  ArrayCreatorRest_1 = DimExpr+ Dim*
  //-------------------------------------------------------------------
  private boolean ArrayCreatorRest_1()
    {
      if (savedInner(ArrayCreatorRest_1)) return reuseInner();
      if (!DimExpr()) return rejectInner();
      while (DimExpr());
      while (Dim());
      return acceptInner();
    }
  
  //=====================================================================
  //  ArrayInitializer = LWING (VariableInitializer (COMMA
  //    VariableInitializer)*)? COMMA? RWING ;
  //=====================================================================
  private boolean ArrayInitializer()
    {
      if (saved(ArrayInitializer)) return reuse();
      if (!LWING()) return reject();
      ArrayInitializer_0();
      COMMA();
      if (!RWING()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ArrayInitializer_0 = VariableInitializer (COMMA
  //    VariableInitializer)*
  //-------------------------------------------------------------------
  private boolean ArrayInitializer_0()
    {
      if (savedInner(ArrayInitializer_0)) return reuseInner();
      if (!VariableInitializer()) return rejectInner();
      while (ArrayInitializer_1());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  ArrayInitializer_1 = COMMA VariableInitializer
  //-------------------------------------------------------------------
  private boolean ArrayInitializer_1()
    {
      if (savedInner(ArrayInitializer_1)) return reuseInner();
      if (!COMMA()) return rejectInner();
      if (!VariableInitializer()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  VariableInitializer = ArrayInitializer / Expression ;
  //=====================================================================
  private boolean VariableInitializer()
    {
      if (saved(VariableInitializer)) return reuse();
      if (ArrayInitializer()) return accept();
      if (Expression()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  ParExpression = LPAR Expression RPAR ;
  //=====================================================================
  private boolean ParExpression()
    {
      if (saved(ParExpression)) return reuse();
      if (!LPAR()) return reject();
      if (!Expression()) return reject();
      if (!RPAR()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  QualifiedIdentifier = Identifier (DOT Identifier)* ;
  //=====================================================================
  private boolean QualifiedIdentifier()
    {
      if (saved(QualifiedIdentifier)) return reuse();
      if (!Identifier()) return reject();
      while (QualifiedIdentifier_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  QualifiedIdentifier_0 = DOT Identifier
  //-------------------------------------------------------------------
  private boolean QualifiedIdentifier_0()
    {
      if (savedInner(QualifiedIdentifier_0)) return reuseInner();
      if (!DOT()) return rejectInner();
      if (!Identifier()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Dim = LBRK RBRK ;
  //=====================================================================
  private boolean Dim()
    {
      if (saved(Dim)) return reuse();
      if (!LBRK()) return reject();
      if (!RBRK()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  DimExpr = LBRK Expression RBRK ;
  //=====================================================================
  private boolean DimExpr()
    {
      if (saved(DimExpr)) return reuse();
      if (!LBRK()) return reject();
      if (!Expression()) return reject();
      if (!RBRK()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Type = (BasicType / ClassType) Dim* ;
  //=====================================================================
  private boolean Type()
    {
      if (saved(Type)) return reuse();
      if (!BasicType()
       && !ClassType()
         ) return reject();
      while (Dim());
      return accept();
    }
  
  //=====================================================================
  //  ReferenceType = BasicType Dim+ / ClassType Dim* ;
  //=====================================================================
  private boolean ReferenceType()
    {
      if (saved(ReferenceType)) return reuse();
      if (ReferenceType_0()) return accept();
      if (ReferenceType_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  ReferenceType_0 = BasicType Dim+
  //-------------------------------------------------------------------
  private boolean ReferenceType_0()
    {
      if (savedInner(ReferenceType_0)) return reuseInner();
      if (!BasicType()) return rejectInner();
      if (!Dim()) return rejectInner();
      while (Dim());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  ReferenceType_1 = ClassType Dim*
  //-------------------------------------------------------------------
  private boolean ReferenceType_1()
    {
      if (savedInner(ReferenceType_1)) return reuseInner();
      if (!ClassType()) return rejectInner();
      while (Dim());
      return acceptInner();
    }
  
  //=====================================================================
  //  ClassType = Identifier TypeArguments? (DOT Identifier
  //    TypeArguments?)* ;
  //=====================================================================
  private boolean ClassType()
    {
      if (saved(ClassType)) return reuse();
      if (!Identifier()) return reject();
      TypeArguments();
      while (ClassType_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ClassType_0 = DOT Identifier TypeArguments?
  //-------------------------------------------------------------------
  private boolean ClassType_0()
    {
      if (savedInner(ClassType_0)) return reuseInner();
      if (!DOT()) return rejectInner();
      if (!Identifier()) return rejectInner();
      TypeArguments();
      return acceptInner();
    }
  
  //=====================================================================
  //  ClassTypeList = ClassType (COMMA ClassType)* ;
  //=====================================================================
  private boolean ClassTypeList()
    {
      if (saved(ClassTypeList)) return reuse();
      if (!ClassType()) return reject();
      while (ClassTypeList_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ClassTypeList_0 = COMMA ClassType
  //-------------------------------------------------------------------
  private boolean ClassTypeList_0()
    {
      if (savedInner(ClassTypeList_0)) return reuseInner();
      if (!COMMA()) return rejectInner();
      if (!ClassType()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  TypeArguments = LPOINT TypeArgument (COMMA TypeArgument)* RPOINT ;
  //=====================================================================
  private boolean TypeArguments()
    {
      if (saved(TypeArguments)) return reuse();
      if (!LPOINT()) return reject();
      if (!TypeArgument()) return reject();
      while (TypeArguments_0());
      if (!RPOINT()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  TypeArguments_0 = COMMA TypeArgument
  //-------------------------------------------------------------------
  private boolean TypeArguments_0()
    {
      if (savedInner(TypeArguments_0)) return reuseInner();
      if (!COMMA()) return rejectInner();
      if (!TypeArgument()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  TypeArgument = ReferenceType / QUERY ((EXTENDS / SUPER)
  //    ReferenceType)? ;
  //=====================================================================
  private boolean TypeArgument()
    {
      if (saved(TypeArgument)) return reuse();
      if (ReferenceType()) return accept();
      if (TypeArgument_0()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  TypeArgument_0 = QUERY ((EXTENDS / SUPER) ReferenceType)?
  //-------------------------------------------------------------------
  private boolean TypeArgument_0()
    {
      if (savedInner(TypeArgument_0)) return reuseInner();
      if (!QUERY()) return rejectInner();
      TypeArgument_1();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TypeArgument_1 = (EXTENDS / SUPER) ReferenceType
  //-------------------------------------------------------------------
  private boolean TypeArgument_1()
    {
      if (savedInner(TypeArgument_1)) return reuseInner();
      if (!EXTENDS()
       && !SUPER()
         ) return rejectInner();
      if (!ReferenceType()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  TypeParameters = LPOINT TypeParameter (COMMA TypeParameter)* RPOINT
  //    ;
  //=====================================================================
  private boolean TypeParameters()
    {
      if (saved(TypeParameters)) return reuse();
      if (!LPOINT()) return reject();
      if (!TypeParameter()) return reject();
      while (TypeParameters_0());
      if (!RPOINT()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  TypeParameters_0 = COMMA TypeParameter
  //-------------------------------------------------------------------
  private boolean TypeParameters_0()
    {
      if (savedInner(TypeParameters_0)) return reuseInner();
      if (!COMMA()) return rejectInner();
      if (!TypeParameter()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  TypeParameter = Identifier (EXTENDS Bound)? ;
  //=====================================================================
  private boolean TypeParameter()
    {
      if (saved(TypeParameter)) return reuse();
      if (!Identifier()) return reject();
      TypeParameter_0();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  TypeParameter_0 = EXTENDS Bound
  //-------------------------------------------------------------------
  private boolean TypeParameter_0()
    {
      if (savedInner(TypeParameter_0)) return reuseInner();
      if (!EXTENDS()) return rejectInner();
      if (!Bound()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Bound = ClassType (AND ClassType)* ;
  //=====================================================================
  private boolean Bound()
    {
      if (saved(Bound)) return reuse();
      if (!ClassType()) return reject();
      while (Bound_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Bound_0 = AND ClassType
  //-------------------------------------------------------------------
  private boolean Bound_0()
    {
      if (savedInner(Bound_0)) return reuseInner();
      if (!AND()) return rejectInner();
      if (!ClassType()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Modifier = Annotation / ("public" / "protected" / "private" /
  //    "static" / "abstract" / "final" / "native" / "synchronized" /
  //    "transient" / "volatile" / "strictfp") !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean Modifier()
    {
      if (saved(Modifier)) return reuse();
      if (Annotation()) return accept();
      if (Modifier_0()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  Modifier_0 = ("public" / "protected" / "private" / "static" /
  //    "abstract" / "final" / "native" / "synchronized" / "transient"
  //    / "volatile" / "strictfp") !LetterOrDigit Spacing
  //-------------------------------------------------------------------
  private boolean Modifier_0()
    {
      if (savedInner(Modifier_0)) return reuseInner();
      if (!next("public")
       && !next("protected")
       && !next("private")
       && !next("static")
       && !next("abstract")
       && !next("final")
       && !next("native")
       && !next("synchronized")
       && !next("transient")
       && !next("volatile")
       && !next("strictfp")
         ) return rejectInner();
      if (!BasicType_0()) return rejectInner();
      Spacing();
      return acceptInner();
    }
  
  //=====================================================================
  //  AnnotationTypeDeclaration = AT INTERFACE Identifier
  //    AnnotationTypeBody ;
  //=====================================================================
  private boolean AnnotationTypeDeclaration()
    {
      if (saved(AnnotationTypeDeclaration)) return reuse();
      if (!AT()) return reject();
      if (!INTERFACE()) return reject();
      if (!Identifier()) return reject();
      if (!AnnotationTypeBody()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  AnnotationTypeBody = LWING AnnotationTypeElementDeclaration* RWING
  //    ;
  //=====================================================================
  private boolean AnnotationTypeBody()
    {
      if (saved(AnnotationTypeBody)) return reuse();
      if (!LWING()) return reject();
      while (AnnotationTypeElementDeclaration());
      if (!RWING()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  AnnotationTypeElementDeclaration = Modifier*
  //    AnnotationTypeElementRest / SEMI ;
  //=====================================================================
  private boolean AnnotationTypeElementDeclaration()
    {
      if (saved(AnnotationTypeElementDeclaration)) return reuse();
      if (AnnotationTypeElementDeclaration_0()) return accept();
      if (SEMI()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  AnnotationTypeElementDeclaration_0 = Modifier*
  //    AnnotationTypeElementRest
  //-------------------------------------------------------------------
  private boolean AnnotationTypeElementDeclaration_0()
    {
      if (savedInner(AnnotationTypeElementDeclaration_0)) return reuseInner();
      while (Modifier());
      if (!AnnotationTypeElementRest()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  AnnotationTypeElementRest = Type AnnotationMethodOrConstantRest
  //    SEMI / ClassDeclaration / EnumDeclaration / InterfaceDeclaration
  //    / AnnotationTypeDeclaration ;
  //=====================================================================
  private boolean AnnotationTypeElementRest()
    {
      if (saved(AnnotationTypeElementRest)) return reuse();
      if (AnnotationTypeElementRest_0()) return accept();
      if (ClassDeclaration()) return accept();
      if (EnumDeclaration()) return accept();
      if (InterfaceDeclaration()) return accept();
      if (AnnotationTypeDeclaration()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  AnnotationTypeElementRest_0 = Type AnnotationMethodOrConstantRest
  //    SEMI
  //-------------------------------------------------------------------
  private boolean AnnotationTypeElementRest_0()
    {
      if (savedInner(AnnotationTypeElementRest_0)) return reuseInner();
      if (!Type()) return rejectInner();
      if (!AnnotationMethodOrConstantRest()) return rejectInner();
      if (!SEMI()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  AnnotationMethodOrConstantRest = AnnotationMethodRest /
  //    AnnotationConstantRest ;
  //=====================================================================
  private boolean AnnotationMethodOrConstantRest()
    {
      if (saved(AnnotationMethodOrConstantRest)) return reuse();
      if (AnnotationMethodRest()) return accept();
      if (AnnotationConstantRest()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  AnnotationMethodRest = Identifier LPAR RPAR DefaultValue? ;
  //=====================================================================
  private boolean AnnotationMethodRest()
    {
      if (saved(AnnotationMethodRest)) return reuse();
      if (!Identifier()) return reject();
      if (!LPAR()) return reject();
      if (!RPAR()) return reject();
      DefaultValue();
      return accept();
    }
  
  //=====================================================================
  //  AnnotationConstantRest = VariableDeclarators ;
  //=====================================================================
  private boolean AnnotationConstantRest()
    {
      if (saved(AnnotationConstantRest)) return reuse();
      if (!VariableDeclarators()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  DefaultValue = DEFAULT ElementValue ;
  //=====================================================================
  private boolean DefaultValue()
    {
      if (saved(DefaultValue)) return reuse();
      if (!DEFAULT()) return reject();
      if (!ElementValue()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Annotation = NormalAnnotation / SingleElementAnnotation /
  //    MarkerAnnotation ;
  //=====================================================================
  private boolean Annotation()
    {
      if (saved(Annotation)) return reuse();
      if (NormalAnnotation()) return accept();
      if (SingleElementAnnotation()) return accept();
      if (MarkerAnnotation()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  NormalAnnotation = AT QualifiedIdentifier LPAR ElementValuePairs?
  //    RPAR ;
  //=====================================================================
  private boolean NormalAnnotation()
    {
      if (saved(NormalAnnotation)) return reuse();
      if (!AT()) return reject();
      if (!QualifiedIdentifier()) return reject();
      if (!LPAR()) return reject();
      ElementValuePairs();
      if (!RPAR()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  SingleElementAnnotation = AT QualifiedIdentifier LPAR ElementValue
  //    RPAR ;
  //=====================================================================
  private boolean SingleElementAnnotation()
    {
      if (saved(SingleElementAnnotation)) return reuse();
      if (!AT()) return reject();
      if (!QualifiedIdentifier()) return reject();
      if (!LPAR()) return reject();
      if (!ElementValue()) return reject();
      if (!RPAR()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  MarkerAnnotation = AT QualifiedIdentifier ;
  //=====================================================================
  private boolean MarkerAnnotation()
    {
      if (saved(MarkerAnnotation)) return reuse();
      if (!AT()) return reject();
      if (!QualifiedIdentifier()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ElementValuePairs = ElementValuePair (COMMA ElementValuePair)* ;
  //=====================================================================
  private boolean ElementValuePairs()
    {
      if (saved(ElementValuePairs)) return reuse();
      if (!ElementValuePair()) return reject();
      while (ElementValuePairs_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ElementValuePairs_0 = COMMA ElementValuePair
  //-------------------------------------------------------------------
  private boolean ElementValuePairs_0()
    {
      if (savedInner(ElementValuePairs_0)) return reuseInner();
      if (!COMMA()) return rejectInner();
      if (!ElementValuePair()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ElementValuePair = Identifier EQU ElementValue ;
  //=====================================================================
  private boolean ElementValuePair()
    {
      if (saved(ElementValuePair)) return reuse();
      if (!Identifier()) return reject();
      if (!EQU()) return reject();
      if (!ElementValue()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ElementValue = ConditionalExpression / Annotation /
  //    ElementValueArrayInitializer ;
  //=====================================================================
  private boolean ElementValue()
    {
      if (saved(ElementValue)) return reuse();
      if (ConditionalExpression()) return accept();
      if (Annotation()) return accept();
      if (ElementValueArrayInitializer()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  ElementValueArrayInitializer = LWING ElementValues? COMMA? RWING ;
  //=====================================================================
  private boolean ElementValueArrayInitializer()
    {
      if (saved(ElementValueArrayInitializer)) return reuse();
      if (!LWING()) return reject();
      ElementValues();
      COMMA();
      if (!RWING()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ElementValues = ElementValue (COMMA ElementValue)* ;
  //=====================================================================
  private boolean ElementValues()
    {
      if (saved(ElementValues)) return reuse();
      if (!ElementValue()) return reject();
      while (ElementValues_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ElementValues_0 = COMMA ElementValue
  //-------------------------------------------------------------------
  private boolean ElementValues_0()
    {
      if (savedInner(ElementValues_0)) return reuseInner();
      if (!COMMA()) return rejectInner();
      if (!ElementValue()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Spacing = ([ \t\r\n\f]+ / "/*" (!"*/" _)* "*/" / "//" (![\r\n] _)*
  //    [\r\n])* ;
  //=====================================================================
  private boolean Spacing()
    {
      if (saved(Spacing)) return reuse();
      while (Spacing_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Spacing_0 = [ \t\r\n\f]+ / "/*" (!"*/" _)* "*/" / "//" (![\r\n]
  //    _)* [\r\n]
  //-------------------------------------------------------------------
  private boolean Spacing_0()
    {
      if (savedInner(Spacing_0)) return reuseInner();
      if (Spacing_1()) return acceptInner();
      if (Spacing_2()) return acceptInner();
      if (Spacing_3()) return acceptInner();
      return rejectInner();
    }
  
  //-------------------------------------------------------------------
  //  Spacing_1 = [ \t\r\n\f]+
  //-------------------------------------------------------------------
  private boolean Spacing_1()
    {
      if (savedInner(Spacing_1)) return reuseInner();
      if (!nextIn(" \t\r\n\f")) return rejectInner();
      while (nextIn(" \t\r\n\f"));
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Spacing_2 = "/*" (!"*/" _)* "*/"
  //-------------------------------------------------------------------
  private boolean Spacing_2()
    {
      if (savedInner(Spacing_2)) return reuseInner();
      if (!next("/*")) return rejectInner();
      while (Spacing_4());
      if (!next("*/")) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Spacing_3 = "//" (![\r\n] _)* [\r\n]
  //-------------------------------------------------------------------
  private boolean Spacing_3()
    {
      if (savedInner(Spacing_3)) return reuseInner();
      if (!next("//")) return rejectInner();
      while (Spacing_5());
      if (!nextIn("\r\n")) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Spacing_4 = !"*/" _
  //-------------------------------------------------------------------
  private boolean Spacing_4()
    {
      if (savedInner(Spacing_4)) return reuseInner();
      if (!aheadNot("*/")) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Spacing_5 = ![\r\n] _
  //-------------------------------------------------------------------
  private boolean Spacing_5()
    {
      if (savedInner(Spacing_5)) return reuseInner();
      if (!aheadNotIn("\r\n")) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Identifier = !Keyword Letter LetterOrDigit* Spacing ;
  //=====================================================================
  private boolean Identifier()
    {
      if (saved(Identifier)) return reuse();
      if (!Identifier_0()) return reject();
      if (!Letter()) return reject();
      while (LetterOrDigit());
      Spacing();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Identifier_0 = !Keyword
  //-------------------------------------------------------------------
  private boolean Identifier_0()
    {
      if (savedInner(Identifier_0)) return reusePred();
      if (Keyword()) return rejectPred();
      return acceptPred();
    }
  
  //=====================================================================
  //  Letter = [a-z] / [A-Z] / [_$] ;
  //=====================================================================
  private boolean Letter()
    {
      if (saved(Letter)) return reuse();
      if (nextIn('a','z')) return accept();
      if (nextIn('A','Z')) return accept();
      if (nextIn("_$")) return accept();
      return reject();
    }
  
  //=====================================================================
  //  LetterOrDigit = [a-z] / [A-Z] / [0-9] / [_$] ;
  //=====================================================================
  private boolean LetterOrDigit()
    {
      if (saved(LetterOrDigit)) return reuse();
      if (nextIn('a','z')) return accept();
      if (nextIn('A','Z')) return accept();
      if (nextIn('0','9')) return accept();
      if (nextIn("_$")) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Keyword = ("abstract" / "assert" / "boolean" / "break" / "byte" /
  //    "case" / "catch" / "char" / "class" / "const" / "continue" /
  //    "default" / "double" / "do" / "else" / "enum" / "extends" /
  //    "false" / "finally" / "final" / "float" / "for" / "goto" / "if" /
  //    "implements" / "import" / "interface" / "int" / "instanceof" /
  //    "long" / "native" / "new" / "null" / "package" / "private" /
  //    "protected" / "public" / "return" / "short" / "static" /
  //    "strictfp" / "super" / "switch" / "synchronized" / "this" /
  //    "throws" / "throw" / "transient" / "true" / "try" / "void" /
  //    "volatile" / "while") !LetterOrDigit ;
  //=====================================================================
  private boolean Keyword()
    {
      if (saved(Keyword)) return reuse();
      if (!next("abstract")
       && !next("assert")
       && !next("boolean")
       && !next("break")
       && !next("byte")
       && !next("case")
       && !next("catch")
       && !next("char")
       && !next("class")
       && !next("const")
       && !next("continue")
       && !next("default")
       && !next("double")
       && !next("do")
       && !next("else")
       && !next("enum")
       && !next("extends")
       && !next("false")
       && !next("finally")
       && !next("final")
       && !next("float")
       && !next("for")
       && !next("goto")
       && !next("if")
       && !next("implements")
       && !next("import")
       && !next("interface")
       && !next("int")
       && !next("instanceof")
       && !next("long")
       && !next("native")
       && !next("new")
       && !next("null")
       && !next("package")
       && !next("private")
       && !next("protected")
       && !next("public")
       && !next("return")
       && !next("short")
       && !next("static")
       && !next("strictfp")
       && !next("super")
       && !next("switch")
       && !next("synchronized")
       && !next("this")
       && !next("throws")
       && !next("throw")
       && !next("transient")
       && !next("true")
       && !next("try")
       && !next("void")
       && !next("volatile")
       && !next("while")
         ) return reject();
      if (!BasicType_0()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  ASSERT = "assert" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean ASSERT()
    {
      if (saved(ASSERT)) return reuse();
      if (!next("assert")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  BREAK = "break" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean BREAK()
    {
      if (saved(BREAK)) return reuse();
      if (!next("break")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  CASE = "case" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean CASE()
    {
      if (saved(CASE)) return reuse();
      if (!next("case")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  CATCH = "catch" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean CATCH()
    {
      if (saved(CATCH)) return reuse();
      if (!next("catch")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  CLASS = "class" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean CLASS()
    {
      if (saved(CLASS)) return reuse();
      if (!next("class")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  CONTINUE = "continue" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean CONTINUE()
    {
      if (saved(CONTINUE)) return reuse();
      if (!next("continue")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  DEFAULT = "default" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean DEFAULT()
    {
      if (saved(DEFAULT)) return reuse();
      if (!next("default")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  DO = "do" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean DO()
    {
      if (saved(DO)) return reuse();
      if (!next("do")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  ELSE = "else" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean ELSE()
    {
      if (saved(ELSE)) return reuse();
      if (!next("else")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  ENUM = "enum" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean ENUM()
    {
      if (saved(ENUM)) return reuse();
      if (!next("enum")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  EXTENDS = "extends" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean EXTENDS()
    {
      if (saved(EXTENDS)) return reuse();
      if (!next("extends")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  FINALLY = "finally" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean FINALLY()
    {
      if (saved(FINALLY)) return reuse();
      if (!next("finally")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  FINAL = "final" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean FINAL()
    {
      if (saved(FINAL)) return reuse();
      if (!next("final")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  FOR = "for" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean FOR()
    {
      if (saved(FOR)) return reuse();
      if (!next("for")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  IF = "if" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean IF()
    {
      if (saved(IF)) return reuse();
      if (!next("if")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  IMPLEMENTS = "implements" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean IMPLEMENTS()
    {
      if (saved(IMPLEMENTS)) return reuse();
      if (!next("implements")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  IMPORT = "import" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean IMPORT()
    {
      if (saved(IMPORT)) return reuse();
      if (!next("import")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  INTERFACE = "interface" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean INTERFACE()
    {
      if (saved(INTERFACE)) return reuse();
      if (!next("interface")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  INSTANCEOF = "instanceof" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean INSTANCEOF()
    {
      if (saved(INSTANCEOF)) return reuse();
      if (!next("instanceof")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  NEW = "new" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean NEW()
    {
      if (saved(NEW)) return reuse();
      if (!next("new")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  PACKAGE = "package" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean PACKAGE()
    {
      if (saved(PACKAGE)) return reuse();
      if (!next("package")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  RETURN = "return" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean RETURN()
    {
      if (saved(RETURN)) return reuse();
      if (!next("return")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  STATIC = "static" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean STATIC()
    {
      if (saved(STATIC)) return reuse();
      if (!next("static")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  SUPER = "super" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean SUPER()
    {
      if (saved(SUPER)) return reuse();
      if (!next("super")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  SWITCH = "switch" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean SWITCH()
    {
      if (saved(SWITCH)) return reuse();
      if (!next("switch")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  SYNCHRONIZED = "synchronized" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean SYNCHRONIZED()
    {
      if (saved(SYNCHRONIZED)) return reuse();
      if (!next("synchronized")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  THIS = "this" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean THIS()
    {
      if (saved(THIS)) return reuse();
      if (!next("this")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  THROWS = "throws" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean THROWS()
    {
      if (saved(THROWS)) return reuse();
      if (!next("throws")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  THROW = "throw" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean THROW()
    {
      if (saved(THROW)) return reuse();
      if (!next("throw")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  TRY = "try" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean TRY()
    {
      if (saved(TRY)) return reuse();
      if (!next("try")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  VOID = "void" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean VOID()
    {
      if (saved(VOID)) return reuse();
      if (!next("void")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  WHILE = "while" !LetterOrDigit Spacing ;
  //=====================================================================
  private boolean WHILE()
    {
      if (saved(WHILE)) return reuse();
      if (!next("while")) return reject();
      if (!BasicType_0()) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  Literal = (FloatLiteral / IntegerLiteral / CharLiteral /
  //    StringLiteral / "true" !LetterOrDigit / "false" !LetterOrDigit /
  //    "null" !LetterOrDigit) Spacing ;
  //=====================================================================
  private boolean Literal()
    {
      if (saved(Literal)) return reuse();
      if (!FloatLiteral()
       && !IntegerLiteral()
       && !CharLiteral()
       && !StringLiteral()
       && !Literal_0()
       && !Literal_1()
       && !Literal_2()
         ) return reject();
      Spacing();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Literal_0 = "true" !LetterOrDigit
  //-------------------------------------------------------------------
  private boolean Literal_0()
    {
      if (savedInner(Literal_0)) return reuseInner();
      if (!next("true")) return rejectInner();
      if (!BasicType_0()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Literal_1 = "false" !LetterOrDigit
  //-------------------------------------------------------------------
  private boolean Literal_1()
    {
      if (savedInner(Literal_1)) return reuseInner();
      if (!next("false")) return rejectInner();
      if (!BasicType_0()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Literal_2 = "null" !LetterOrDigit
  //-------------------------------------------------------------------
  private boolean Literal_2()
    {
      if (savedInner(Literal_2)) return reuseInner();
      if (!next("null")) return rejectInner();
      if (!BasicType_0()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  IntegerLiteral = (HexNumeral / BinaryNumeral / OctalNumeral /
  //    DecimalNumeral) [lL]? ;
  //=====================================================================
  private boolean IntegerLiteral()
    {
      if (saved(IntegerLiteral)) return reuse();
      if (!HexNumeral()
       && !BinaryNumeral()
       && !OctalNumeral()
       && !DecimalNumeral()
         ) return reject();
      nextIn("lL");
      return accept();
    }
  
  //=====================================================================
  //  DecimalNumeral = "0" / [1-9] ([_]* [0-9])* ;
  //=====================================================================
  private boolean DecimalNumeral()
    {
      if (saved(DecimalNumeral)) return reuse();
      if (next('0')) return accept();
      if (DecimalNumeral_0()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  DecimalNumeral_0 = [1-9] ([_]* [0-9])*
  //-------------------------------------------------------------------
  private boolean DecimalNumeral_0()
    {
      if (savedInner(DecimalNumeral_0)) return reuseInner();
      if (!nextIn('1','9')) return rejectInner();
      while (DecimalNumeral_1());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  DecimalNumeral_1 = [_]* [0-9]
  //-------------------------------------------------------------------
  private boolean DecimalNumeral_1()
    {
      if (savedInner(DecimalNumeral_1)) return reuseInner();
      while (next('_'));
      if (!nextIn('0','9')) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  HexNumeral = ("0x" / "0X") HexDigits ;
  //=====================================================================
  private boolean HexNumeral()
    {
      if (saved(HexNumeral)) return reuse();
      if (!next("0x")
       && !next("0X")
         ) return reject();
      if (!HexDigits()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  BinaryNumeral = ("0b" / "0B") [01] ([_]* [01])* ;
  //=====================================================================
  private boolean BinaryNumeral()
    {
      if (saved(BinaryNumeral)) return reuse();
      if (!next("0b")
       && !next("0B")
         ) return reject();
      if (!nextIn("01")) return reject();
      while (BinaryNumeral_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  BinaryNumeral_0 = [_]* [01]
  //-------------------------------------------------------------------
  private boolean BinaryNumeral_0()
    {
      if (savedInner(BinaryNumeral_0)) return reuseInner();
      while (next('_'));
      if (!nextIn("01")) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  OctalNumeral = "0" ([_]* [0-7])+ ;
  //=====================================================================
  private boolean OctalNumeral()
    {
      if (saved(OctalNumeral)) return reuse();
      if (!next('0')) return reject();
      if (!OctalNumeral_0()) return reject();
      while (OctalNumeral_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  OctalNumeral_0 = [_]* [0-7]
  //-------------------------------------------------------------------
  private boolean OctalNumeral_0()
    {
      if (savedInner(OctalNumeral_0)) return reuseInner();
      while (next('_'));
      if (!nextIn('0','7')) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  FloatLiteral = HexFloat / DecimalFloat ;
  //=====================================================================
  private boolean FloatLiteral()
    {
      if (saved(FloatLiteral)) return reuse();
      if (HexFloat()) return accept();
      if (DecimalFloat()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  DecimalFloat = Digits "." Digits? Exponent? [fFdD]? / "." Digits
  //    Exponent? [fFdD]? / Digits Exponent [fFdD]? / Digits Exponent?
  //    [fFdD] ;
  //=====================================================================
  private boolean DecimalFloat()
    {
      if (saved(DecimalFloat)) return reuse();
      if (DecimalFloat_0()) return accept();
      if (DecimalFloat_1()) return accept();
      if (DecimalFloat_2()) return accept();
      if (DecimalFloat_3()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  DecimalFloat_0 = Digits "." Digits? Exponent? [fFdD]?
  //-------------------------------------------------------------------
  private boolean DecimalFloat_0()
    {
      if (savedInner(DecimalFloat_0)) return reuseInner();
      if (!Digits()) return rejectInner();
      if (!next('.')) return rejectInner();
      Digits();
      Exponent();
      nextIn("fFdD");
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  DecimalFloat_1 = "." Digits Exponent? [fFdD]?
  //-------------------------------------------------------------------
  private boolean DecimalFloat_1()
    {
      if (savedInner(DecimalFloat_1)) return reuseInner();
      if (!next('.')) return rejectInner();
      if (!Digits()) return rejectInner();
      Exponent();
      nextIn("fFdD");
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  DecimalFloat_2 = Digits Exponent [fFdD]?
  //-------------------------------------------------------------------
  private boolean DecimalFloat_2()
    {
      if (savedInner(DecimalFloat_2)) return reuseInner();
      if (!Digits()) return rejectInner();
      if (!Exponent()) return rejectInner();
      nextIn("fFdD");
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  DecimalFloat_3 = Digits Exponent? [fFdD]
  //-------------------------------------------------------------------
  private boolean DecimalFloat_3()
    {
      if (savedInner(DecimalFloat_3)) return reuseInner();
      if (!Digits()) return rejectInner();
      Exponent();
      if (!nextIn("fFdD")) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Exponent = [eE] [+-]? Digits ;
  //=====================================================================
  private boolean Exponent()
    {
      if (saved(Exponent)) return reuse();
      if (!nextIn("eE")) return reject();
      nextIn("+-");
      if (!Digits()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  HexFloat = HexSignificand BinaryExponent [fFdD]? ;
  //=====================================================================
  private boolean HexFloat()
    {
      if (saved(HexFloat)) return reuse();
      if (!HexSignificand()) return reject();
      if (!BinaryExponent()) return reject();
      nextIn("fFdD");
      return accept();
    }
  
  //=====================================================================
  //  HexSignificand = ("0x" / "0X") HexDigits? "." HexDigits /
  //    HexNumeral "."? ;
  //=====================================================================
  private boolean HexSignificand()
    {
      if (saved(HexSignificand)) return reuse();
      if (HexSignificand_0()) return accept();
      if (HexSignificand_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  HexSignificand_0 = ("0x" / "0X") HexDigits? "." HexDigits
  //-------------------------------------------------------------------
  private boolean HexSignificand_0()
    {
      if (savedInner(HexSignificand_0)) return reuseInner();
      if (!next("0x")
       && !next("0X")
         ) return rejectInner();
      HexDigits();
      if (!next('.')) return rejectInner();
      if (!HexDigits()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  HexSignificand_1 = HexNumeral "."?
  //-------------------------------------------------------------------
  private boolean HexSignificand_1()
    {
      if (savedInner(HexSignificand_1)) return reuseInner();
      if (!HexNumeral()) return rejectInner();
      next('.');
      return acceptInner();
    }
  
  //=====================================================================
  //  BinaryExponent = [pP] [+-]? Digits ;
  //=====================================================================
  private boolean BinaryExponent()
    {
      if (saved(BinaryExponent)) return reuse();
      if (!nextIn("pP")) return reject();
      nextIn("+-");
      if (!Digits()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Digits = [0-9] ([_]* [0-9])* ;
  //=====================================================================
  private boolean Digits()
    {
      if (saved(Digits)) return reuse();
      if (!nextIn('0','9')) return reject();
      while (DecimalNumeral_1());
      return accept();
    }
  
  //=====================================================================
  //  HexDigits = HexDigit ([_]* HexDigit)* ;
  //=====================================================================
  private boolean HexDigits()
    {
      if (saved(HexDigits)) return reuse();
      if (!HexDigit()) return reject();
      while (HexDigits_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  HexDigits_0 = [_]* HexDigit
  //-------------------------------------------------------------------
  private boolean HexDigits_0()
    {
      if (savedInner(HexDigits_0)) return reuseInner();
      while (next('_'));
      if (!HexDigit()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  HexDigit = [a-f] / [A-F] / [0-9] ;
  //=====================================================================
  private boolean HexDigit()
    {
      if (saved(HexDigit)) return reuse();
      if (nextIn('a','f')) return accept();
      if (nextIn('A','F')) return accept();
      if (nextIn('0','9')) return accept();
      return reject();
    }
  
  //=====================================================================
  //  CharLiteral = "'" (Escape / !['\\n\r] _) "'" ;
  //=====================================================================
  private boolean CharLiteral()
    {
      if (saved(CharLiteral)) return reuse();
      if (!next('\'')) return reject();
      if (!Escape()
       && !CharLiteral_0()
         ) return reject();
      if (!next('\'')) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  CharLiteral_0 = !['\\n\r] _
  //-------------------------------------------------------------------
  private boolean CharLiteral_0()
    {
      if (savedInner(CharLiteral_0)) return reuseInner();
      if (!aheadNotIn("'\\\n\r")) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  StringLiteral = """ (Escape / !["\\n\r] _)* """ ;
  //=====================================================================
  private boolean StringLiteral()
    {
      if (saved(StringLiteral)) return reuse();
      if (!next('"')) return reject();
      while (StringLiteral_0());
      if (!next('"')) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  StringLiteral_0 = Escape / !["\\n\r] _
  //-------------------------------------------------------------------
  private boolean StringLiteral_0()
    {
      if (savedInner(StringLiteral_0)) return reuseInner();
      if (Escape()) return acceptInner();
      if (StringLiteral_1()) return acceptInner();
      return rejectInner();
    }
  
  //-------------------------------------------------------------------
  //  StringLiteral_1 = !["\\n\r] _
  //-------------------------------------------------------------------
  private boolean StringLiteral_1()
    {
      if (savedInner(StringLiteral_1)) return reuseInner();
      if (!aheadNotIn("\"\\\n\r")) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Escape = "\" ([btnfr"'\] / OctalEscape / UnicodeEscape) ;
  //=====================================================================
  private boolean Escape()
    {
      if (saved(Escape)) return reuse();
      if (!next('\\')) return reject();
      if (!nextIn("btnfr\"'\\")
       && !OctalEscape()
       && !UnicodeEscape()
         ) return reject();
      return accept();
    }
  
  //=====================================================================
  //  OctalEscape = [0-3] [0-7] [0-7] / [0-7] [0-7] / [0-7] ;
  //=====================================================================
  private boolean OctalEscape()
    {
      if (saved(OctalEscape)) return reuse();
      if (OctalEscape_0()) return accept();
      if (OctalEscape_1()) return accept();
      if (nextIn('0','7')) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  OctalEscape_0 = [0-3] [0-7] [0-7]
  //-------------------------------------------------------------------
  private boolean OctalEscape_0()
    {
      if (savedInner(OctalEscape_0)) return reuseInner();
      if (!nextIn('0','3')) return rejectInner();
      if (!nextIn('0','7')) return rejectInner();
      if (!nextIn('0','7')) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  OctalEscape_1 = [0-7] [0-7]
  //-------------------------------------------------------------------
  private boolean OctalEscape_1()
    {
      if (savedInner(OctalEscape_1)) return reuseInner();
      if (!nextIn('0','7')) return rejectInner();
      if (!nextIn('0','7')) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  UnicodeEscape = "u"+ HexDigit HexDigit HexDigit HexDigit ;
  //=====================================================================
  private boolean UnicodeEscape()
    {
      if (saved(UnicodeEscape)) return reuse();
      if (!next('u')) return reject();
      while (next('u'));
      if (!HexDigit()) return reject();
      if (!HexDigit()) return reject();
      if (!HexDigit()) return reject();
      if (!HexDigit()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  AT = "@" Spacing ;
  //=====================================================================
  private boolean AT()
    {
      if (saved(AT)) return reuse();
      if (!next('@')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  AND = "&" ![=&] Spacing ;
  //=====================================================================
  private boolean AND()
    {
      if (saved(AND)) return reuse();
      if (!next('&')) return reject();
      if (!aheadNotIn("=&")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  ANDAND = "&&" Spacing ;
  //=====================================================================
  private boolean ANDAND()
    {
      if (saved(ANDAND)) return reuse();
      if (!next("&&")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  ANDEQU = "&=" Spacing ;
  //=====================================================================
  private boolean ANDEQU()
    {
      if (saved(ANDEQU)) return reuse();
      if (!next("&=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  BANG = "!" !"=" Spacing ;
  //=====================================================================
  private boolean BANG()
    {
      if (saved(BANG)) return reuse();
      if (!next('!')) return reject();
      if (!aheadNot('=')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  BSR = ">>>" !"=" Spacing ;
  //=====================================================================
  private boolean BSR()
    {
      if (saved(BSR)) return reuse();
      if (!next(">>>")) return reject();
      if (!aheadNot('=')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  BSREQU = ">>>=" Spacing ;
  //=====================================================================
  private boolean BSREQU()
    {
      if (saved(BSREQU)) return reuse();
      if (!next(">>>=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  COLON = ":" Spacing ;
  //=====================================================================
  private boolean COLON()
    {
      if (saved(COLON)) return reuse();
      if (!next(':')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  COMMA = "," Spacing ;
  //=====================================================================
  private boolean COMMA()
    {
      if (saved(COMMA)) return reuse();
      if (!next(',')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  DEC = "--" Spacing ;
  //=====================================================================
  private boolean DEC()
    {
      if (saved(DEC)) return reuse();
      if (!next("--")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  DIV = "/" !"=" Spacing ;
  //=====================================================================
  private boolean DIV()
    {
      if (saved(DIV)) return reuse();
      if (!next('/')) return reject();
      if (!aheadNot('=')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  DIVEQU = "/=" Spacing ;
  //=====================================================================
  private boolean DIVEQU()
    {
      if (saved(DIVEQU)) return reuse();
      if (!next("/=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  DOT = "." Spacing ;
  //=====================================================================
  private boolean DOT()
    {
      if (saved(DOT)) return reuse();
      if (!next('.')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  ELLIPSIS = "..." Spacing ;
  //=====================================================================
  private boolean ELLIPSIS()
    {
      if (saved(ELLIPSIS)) return reuse();
      if (!next("...")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  EQU = "=" !"=" Spacing ;
  //=====================================================================
  private boolean EQU()
    {
      if (saved(EQU)) return reuse();
      if (!next('=')) return reject();
      if (!aheadNot('=')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  EQUAL = "==" Spacing ;
  //=====================================================================
  private boolean EQUAL()
    {
      if (saved(EQUAL)) return reuse();
      if (!next("==")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  GE = ">=" Spacing ;
  //=====================================================================
  private boolean GE()
    {
      if (saved(GE)) return reuse();
      if (!next(">=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  GT = ">" ![=>] Spacing ;
  //=====================================================================
  private boolean GT()
    {
      if (saved(GT)) return reuse();
      if (!next('>')) return reject();
      if (!aheadNotIn("=>")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  HAT = "^" !"=" Spacing ;
  //=====================================================================
  private boolean HAT()
    {
      if (saved(HAT)) return reuse();
      if (!next('^')) return reject();
      if (!aheadNot('=')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  HATEQU = "^=" Spacing ;
  //=====================================================================
  private boolean HATEQU()
    {
      if (saved(HATEQU)) return reuse();
      if (!next("^=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  INC = "++" Spacing ;
  //=====================================================================
  private boolean INC()
    {
      if (saved(INC)) return reuse();
      if (!next("++")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  LBRK = "[" Spacing ;
  //=====================================================================
  private boolean LBRK()
    {
      if (saved(LBRK)) return reuse();
      if (!next('[')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  LE = "<=" Spacing ;
  //=====================================================================
  private boolean LE()
    {
      if (saved(LE)) return reuse();
      if (!next("<=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  LPAR = "(" Spacing ;
  //=====================================================================
  private boolean LPAR()
    {
      if (saved(LPAR)) return reuse();
      if (!next('(')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  LPOINT = "<" Spacing ;
  //=====================================================================
  private boolean LPOINT()
    {
      if (saved(LPOINT)) return reuse();
      if (!next('<')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  LT = "<" ![=<] Spacing ;
  //=====================================================================
  private boolean LT()
    {
      if (saved(LT)) return reuse();
      if (!next('<')) return reject();
      if (!aheadNotIn("=<")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  LWING = "{" Spacing ;
  //=====================================================================
  private boolean LWING()
    {
      if (saved(LWING)) return reuse();
      if (!next('{')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  MINUS = "-" ![=-] Spacing ;
  //=====================================================================
  private boolean MINUS()
    {
      if (saved(MINUS)) return reuse();
      if (!next('-')) return reject();
      if (!aheadNotIn("=-")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  MINUSEQU = "-=" Spacing ;
  //=====================================================================
  private boolean MINUSEQU()
    {
      if (saved(MINUSEQU)) return reuse();
      if (!next("-=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  MOD = "%" !"=" Spacing ;
  //=====================================================================
  private boolean MOD()
    {
      if (saved(MOD)) return reuse();
      if (!next('%')) return reject();
      if (!aheadNot('=')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  MODEQU = "%=" Spacing ;
  //=====================================================================
  private boolean MODEQU()
    {
      if (saved(MODEQU)) return reuse();
      if (!next("%=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  NOTEQUAL = "!=" Spacing ;
  //=====================================================================
  private boolean NOTEQUAL()
    {
      if (saved(NOTEQUAL)) return reuse();
      if (!next("!=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  OR = "|" ![=|] Spacing ;
  //=====================================================================
  private boolean OR()
    {
      if (saved(OR)) return reuse();
      if (!next('|')) return reject();
      if (!aheadNotIn("=|")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  OREQU = "|=" Spacing ;
  //=====================================================================
  private boolean OREQU()
    {
      if (saved(OREQU)) return reuse();
      if (!next("|=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  OROR = "||" Spacing ;
  //=====================================================================
  private boolean OROR()
    {
      if (saved(OROR)) return reuse();
      if (!next("||")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  PLUS = "+" ![=+] Spacing ;
  //=====================================================================
  private boolean PLUS()
    {
      if (saved(PLUS)) return reuse();
      if (!next('+')) return reject();
      if (!aheadNotIn("=+")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  PLUSEQU = "+=" Spacing ;
  //=====================================================================
  private boolean PLUSEQU()
    {
      if (saved(PLUSEQU)) return reuse();
      if (!next("+=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  QUERY = "?" Spacing ;
  //=====================================================================
  private boolean QUERY()
    {
      if (saved(QUERY)) return reuse();
      if (!next('?')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  RBRK = "]" Spacing ;
  //=====================================================================
  private boolean RBRK()
    {
      if (saved(RBRK)) return reuse();
      if (!next(']')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  RPAR = ")" Spacing ;
  //=====================================================================
  private boolean RPAR()
    {
      if (saved(RPAR)) return reuse();
      if (!next(')')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  RPOINT = ">" Spacing ;
  //=====================================================================
  private boolean RPOINT()
    {
      if (saved(RPOINT)) return reuse();
      if (!next('>')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  RWING = "}" Spacing ;
  //=====================================================================
  private boolean RWING()
    {
      if (saved(RWING)) return reuse();
      if (!next('}')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  SEMI = ";" Spacing ;
  //=====================================================================
  private boolean SEMI()
    {
      if (saved(SEMI)) return reuse();
      if (!next(';')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  SL = "<<" !"=" Spacing ;
  //=====================================================================
  private boolean SL()
    {
      if (saved(SL)) return reuse();
      if (!next("<<")) return reject();
      if (!aheadNot('=')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  SLEQU = "<<=" Spacing ;
  //=====================================================================
  private boolean SLEQU()
    {
      if (saved(SLEQU)) return reuse();
      if (!next("<<=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  SR = ">>" ![=>] Spacing ;
  //=====================================================================
  private boolean SR()
    {
      if (saved(SR)) return reuse();
      if (!next(">>")) return reject();
      if (!aheadNotIn("=>")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  SREQU = ">>=" Spacing ;
  //=====================================================================
  private boolean SREQU()
    {
      if (saved(SREQU)) return reuse();
      if (!next(">>=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  STAR = "*" !"=" Spacing ;
  //=====================================================================
  private boolean STAR()
    {
      if (saved(STAR)) return reuse();
      if (!next('*')) return reject();
      if (!aheadNot('=')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  STAREQU = "*=" Spacing ;
  //=====================================================================
  private boolean STAREQU()
    {
      if (saved(STAREQU)) return reuse();
      if (!next("*=")) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  TILDA = "~" Spacing ;
  //=====================================================================
  private boolean TILDA()
    {
      if (saved(TILDA)) return reuse();
      if (!next('~')) return reject();
      Spacing();
      return accept();
    }
  
  //=====================================================================
  //  EOT = !_ ;
  //=====================================================================
  private boolean EOT()
    {
      if (saved(EOT)) return reuse();
      if (!aheadNot()) return reject();
      return accept();
    }
  
  //=======================================================================
  //
  //  Cache objects
  //
  //=======================================================================
  
  final Cache CompilationUnit = new Cache("CompilationUnit","CompilationUnit");
  final Cache PackageDeclaration = new Cache("PackageDeclaration","PackageDeclaration");
  final Cache ImportDeclaration = new Cache("ImportDeclaration","ImportDeclaration");
  final Cache TypeDeclaration = new Cache("TypeDeclaration","TypeDeclaration");
  final Cache ClassDeclaration = new Cache("ClassDeclaration","ClassDeclaration");
  final Cache ClassBody = new Cache("ClassBody","ClassBody");
  final Cache ClassBodyDeclaration = new Cache("ClassBodyDeclaration","ClassBodyDeclaration");
  final Cache MemberDecl = new Cache("MemberDecl","MemberDecl");
  final Cache GenericMethodOrConstructorRest = new Cache("GenericMethodOrConstructorRest","GenericMethodOrConstructorRest");
  final Cache MethodDeclaratorRest = new Cache("MethodDeclaratorRest","MethodDeclaratorRest");
  final Cache VoidMethodDeclaratorRest = new Cache("VoidMethodDeclaratorRest","VoidMethodDeclaratorRest");
  final Cache ConstructorDeclaratorRest = new Cache("ConstructorDeclaratorRest","ConstructorDeclaratorRest");
  final Cache MethodBody = new Cache("MethodBody","MethodBody");
  final Cache InterfaceDeclaration = new Cache("InterfaceDeclaration","InterfaceDeclaration");
  final Cache InterfaceBody = new Cache("InterfaceBody","InterfaceBody");
  final Cache InterfaceBodyDeclaration = new Cache("InterfaceBodyDeclaration","InterfaceBodyDeclaration");
  final Cache InterfaceMemberDecl = new Cache("InterfaceMemberDecl","InterfaceMemberDecl");
  final Cache InterfaceMethodOrFieldDecl = new Cache("InterfaceMethodOrFieldDecl","InterfaceMethodOrFieldDecl");
  final Cache InterfaceMethodOrFieldRest = new Cache("InterfaceMethodOrFieldRest","InterfaceMethodOrFieldRest");
  final Cache InterfaceMethodDeclaratorRest = new Cache("InterfaceMethodDeclaratorRest","InterfaceMethodDeclaratorRest");
  final Cache InterfaceGenericMethodDecl = new Cache("InterfaceGenericMethodDecl","InterfaceGenericMethodDecl");
  final Cache VoidInterfaceMethodDeclaratorRest = new Cache("VoidInterfaceMethodDeclaratorRest","VoidInterfaceMethodDeclaratorRest");
  final Cache ConstantDeclaratorsRest = new Cache("ConstantDeclaratorsRest","ConstantDeclaratorsRest");
  final Cache ConstantDeclarator = new Cache("ConstantDeclarator","ConstantDeclarator");
  final Cache ConstantDeclaratorRest = new Cache("ConstantDeclaratorRest","ConstantDeclaratorRest");
  final Cache EnumDeclaration = new Cache("EnumDeclaration","EnumDeclaration");
  final Cache EnumBody = new Cache("EnumBody","EnumBody");
  final Cache EnumConstants = new Cache("EnumConstants","EnumConstants");
  final Cache EnumConstant = new Cache("EnumConstant","EnumConstant");
  final Cache EnumBodyDeclarations = new Cache("EnumBodyDeclarations","EnumBodyDeclarations");
  final Cache LocalVariableDeclarationStatement = new Cache("LocalVariableDeclarationStatement","LocalVariableDeclarationStatement");
  final Cache VariableDeclarators = new Cache("VariableDeclarators","VariableDeclarators");
  final Cache VariableDeclarator = new Cache("VariableDeclarator","VariableDeclarator");
  final Cache FormalParameters = new Cache("FormalParameters","FormalParameters");
  final Cache FormalParameter = new Cache("FormalParameter","FormalParameter");
  final Cache LastFormalParameter = new Cache("LastFormalParameter","LastFormalParameter");
  final Cache FormalParameterList = new Cache("FormalParameterList","FormalParameterList");
  final Cache VariableDeclaratorId = new Cache("VariableDeclaratorId","VariableDeclaratorId");
  final Cache Block = new Cache("Block","Block");
  final Cache BlockStatements = new Cache("BlockStatements","BlockStatements");
  final Cache BlockStatement = new Cache("BlockStatement","BlockStatement");
  final Cache Statement = new Cache("Statement","Statement");
  final Cache Resource = new Cache("Resource","Resource");
  final Cache Catch = new Cache("Catch","Catch");
  final Cache Finally = new Cache("Finally","Finally");
  final Cache SwitchBlockStatementGroups = new Cache("SwitchBlockStatementGroups","SwitchBlockStatementGroups");
  final Cache SwitchBlockStatementGroup = new Cache("SwitchBlockStatementGroup","SwitchBlockStatementGroup");
  final Cache SwitchLabel = new Cache("SwitchLabel","SwitchLabel");
  final Cache ForInit = new Cache("ForInit","ForInit");
  final Cache ForUpdate = new Cache("ForUpdate","ForUpdate");
  final Cache EnumConstantName = new Cache("EnumConstantName","EnumConstantName");
  final Cache StatementExpression = new Cache("StatementExpression","StatementExpression");
  final Cache ConstantExpression = new Cache("ConstantExpression","ConstantExpression");
  final Cache Expression = new Cache("Expression","Expression");
  final Cache AssignmentOperator = new Cache("AssignmentOperator","AssignmentOperator");
  final Cache ConditionalExpression = new Cache("ConditionalExpression","ConditionalExpression");
  final Cache ConditionalOrExpression = new Cache("ConditionalOrExpression","ConditionalOrExpression");
  final Cache ConditionalAndExpression = new Cache("ConditionalAndExpression","ConditionalAndExpression");
  final Cache InclusiveOrExpression = new Cache("InclusiveOrExpression","InclusiveOrExpression");
  final Cache ExclusiveOrExpression = new Cache("ExclusiveOrExpression","ExclusiveOrExpression");
  final Cache AndExpression = new Cache("AndExpression","AndExpression");
  final Cache EqualityExpression = new Cache("EqualityExpression","EqualityExpression");
  final Cache RelationalExpression = new Cache("RelationalExpression","RelationalExpression");
  final Cache ShiftExpression = new Cache("ShiftExpression","ShiftExpression");
  final Cache AdditiveExpression = new Cache("AdditiveExpression","AdditiveExpression");
  final Cache MultiplicativeExpression = new Cache("MultiplicativeExpression","MultiplicativeExpression");
  final Cache UnaryExpression = new Cache("UnaryExpression","UnaryExpression");
  final Cache Primary = new Cache("Primary","Primary");
  final Cache IdentifierSuffix = new Cache("IdentifierSuffix","IdentifierSuffix");
  final Cache ExplicitGenericInvocation = new Cache("ExplicitGenericInvocation","ExplicitGenericInvocation");
  final Cache NonWildcardTypeArguments = new Cache("NonWildcardTypeArguments","NonWildcardTypeArguments");
  final Cache TypeArgumentsOrDiamond = new Cache("TypeArgumentsOrDiamond","TypeArgumentsOrDiamond");
  final Cache NonWildcardTypeArgumentsOrDiamond = new Cache("NonWildcardTypeArgumentsOrDiamond","NonWildcardTypeArgumentsOrDiamond");
  final Cache ExplicitGenericInvocationSuffix = new Cache("ExplicitGenericInvocationSuffix","ExplicitGenericInvocationSuffix");
  final Cache PrefixOp = new Cache("PrefixOp","PrefixOp");
  final Cache PostfixOp = new Cache("PostfixOp","PostfixOp");
  final Cache Selector = new Cache("Selector","Selector");
  final Cache SuperSuffix = new Cache("SuperSuffix","SuperSuffix");
  final Cache BasicType = new Cache("BasicType","BasicType");
  final Cache Arguments = new Cache("Arguments","Arguments");
  final Cache Creator = new Cache("Creator","Creator");
  final Cache CreatedName = new Cache("CreatedName","CreatedName");
  final Cache InnerCreator = new Cache("InnerCreator","InnerCreator");
  final Cache ClassCreatorRest = new Cache("ClassCreatorRest","ClassCreatorRest");
  final Cache ArrayCreatorRest = new Cache("ArrayCreatorRest","ArrayCreatorRest");
  final Cache ArrayInitializer = new Cache("ArrayInitializer","ArrayInitializer");
  final Cache VariableInitializer = new Cache("VariableInitializer","VariableInitializer");
  final Cache ParExpression = new Cache("ParExpression","ParExpression");
  final Cache QualifiedIdentifier = new Cache("QualifiedIdentifier","QualifiedIdentifier");
  final Cache Dim = new Cache("Dim","Dim");
  final Cache DimExpr = new Cache("DimExpr","DimExpr");
  final Cache Type = new Cache("Type","Type");
  final Cache ReferenceType = new Cache("ReferenceType","ReferenceType");
  final Cache ClassType = new Cache("ClassType","ClassType");
  final Cache ClassTypeList = new Cache("ClassTypeList","ClassTypeList");
  final Cache TypeArguments = new Cache("TypeArguments","TypeArguments");
  final Cache TypeArgument = new Cache("TypeArgument","TypeArgument");
  final Cache TypeParameters = new Cache("TypeParameters","TypeParameters");
  final Cache TypeParameter = new Cache("TypeParameter","TypeParameter");
  final Cache Bound = new Cache("Bound","Bound");
  final Cache Modifier = new Cache("Modifier","Modifier");
  final Cache AnnotationTypeDeclaration = new Cache("AnnotationTypeDeclaration","AnnotationTypeDeclaration");
  final Cache AnnotationTypeBody = new Cache("AnnotationTypeBody","AnnotationTypeBody");
  final Cache AnnotationTypeElementDeclaration = new Cache("AnnotationTypeElementDeclaration","AnnotationTypeElementDeclaration");
  final Cache AnnotationTypeElementRest = new Cache("AnnotationTypeElementRest","AnnotationTypeElementRest");
  final Cache AnnotationMethodOrConstantRest = new Cache("AnnotationMethodOrConstantRest","AnnotationMethodOrConstantRest");
  final Cache AnnotationMethodRest = new Cache("AnnotationMethodRest","AnnotationMethodRest");
  final Cache AnnotationConstantRest = new Cache("AnnotationConstantRest","AnnotationConstantRest");
  final Cache DefaultValue = new Cache("DefaultValue","DefaultValue");
  final Cache Annotation = new Cache("Annotation","Annotation");
  final Cache NormalAnnotation = new Cache("NormalAnnotation","NormalAnnotation");
  final Cache SingleElementAnnotation = new Cache("SingleElementAnnotation","SingleElementAnnotation");
  final Cache MarkerAnnotation = new Cache("MarkerAnnotation","MarkerAnnotation");
  final Cache ElementValuePairs = new Cache("ElementValuePairs","ElementValuePairs");
  final Cache ElementValuePair = new Cache("ElementValuePair","ElementValuePair");
  final Cache ElementValue = new Cache("ElementValue","ElementValue");
  final Cache ElementValueArrayInitializer = new Cache("ElementValueArrayInitializer","ElementValueArrayInitializer");
  final Cache ElementValues = new Cache("ElementValues","ElementValues");
  final Cache Spacing = new Cache("Spacing","Spacing");
  final Cache Identifier = new Cache("Identifier","Identifier");
  final Cache Letter = new Cache("Letter","Letter");
  final Cache LetterOrDigit = new Cache("LetterOrDigit","LetterOrDigit");
  final Cache Keyword = new Cache("Keyword","Keyword");
  final Cache ASSERT = new Cache("ASSERT","ASSERT");
  final Cache BREAK = new Cache("BREAK","BREAK");
  final Cache CASE = new Cache("CASE","CASE");
  final Cache CATCH = new Cache("CATCH","CATCH");
  final Cache CLASS = new Cache("CLASS","CLASS");
  final Cache CONTINUE = new Cache("CONTINUE","CONTINUE");
  final Cache DEFAULT = new Cache("DEFAULT","DEFAULT");
  final Cache DO = new Cache("DO","DO");
  final Cache ELSE = new Cache("ELSE","ELSE");
  final Cache ENUM = new Cache("ENUM","ENUM");
  final Cache EXTENDS = new Cache("EXTENDS","EXTENDS");
  final Cache FINALLY = new Cache("FINALLY","FINALLY");
  final Cache FINAL = new Cache("FINAL","FINAL");
  final Cache FOR = new Cache("FOR","FOR");
  final Cache IF = new Cache("IF","IF");
  final Cache IMPLEMENTS = new Cache("IMPLEMENTS","IMPLEMENTS");
  final Cache IMPORT = new Cache("IMPORT","IMPORT");
  final Cache INTERFACE = new Cache("INTERFACE","INTERFACE");
  final Cache INSTANCEOF = new Cache("INSTANCEOF","INSTANCEOF");
  final Cache NEW = new Cache("NEW","NEW");
  final Cache PACKAGE = new Cache("PACKAGE","PACKAGE");
  final Cache RETURN = new Cache("RETURN","RETURN");
  final Cache STATIC = new Cache("STATIC","STATIC");
  final Cache SUPER = new Cache("SUPER","SUPER");
  final Cache SWITCH = new Cache("SWITCH","SWITCH");
  final Cache SYNCHRONIZED = new Cache("SYNCHRONIZED","SYNCHRONIZED");
  final Cache THIS = new Cache("THIS","THIS");
  final Cache THROWS = new Cache("THROWS","THROWS");
  final Cache THROW = new Cache("THROW","THROW");
  final Cache TRY = new Cache("TRY","TRY");
  final Cache VOID = new Cache("VOID","VOID");
  final Cache WHILE = new Cache("WHILE","WHILE");
  final Cache Literal = new Cache("Literal","Literal");
  final Cache IntegerLiteral = new Cache("IntegerLiteral","IntegerLiteral");
  final Cache DecimalNumeral = new Cache("DecimalNumeral","DecimalNumeral");
  final Cache HexNumeral = new Cache("HexNumeral","HexNumeral");
  final Cache BinaryNumeral = new Cache("BinaryNumeral","BinaryNumeral");
  final Cache OctalNumeral = new Cache("OctalNumeral","OctalNumeral");
  final Cache FloatLiteral = new Cache("FloatLiteral","FloatLiteral");
  final Cache DecimalFloat = new Cache("DecimalFloat","DecimalFloat");
  final Cache Exponent = new Cache("Exponent","Exponent");
  final Cache HexFloat = new Cache("HexFloat","HexFloat");
  final Cache HexSignificand = new Cache("HexSignificand","HexSignificand");
  final Cache BinaryExponent = new Cache("BinaryExponent","BinaryExponent");
  final Cache Digits = new Cache("Digits","Digits");
  final Cache HexDigits = new Cache("HexDigits","HexDigits");
  final Cache HexDigit = new Cache("HexDigit","HexDigit");
  final Cache CharLiteral = new Cache("CharLiteral","CharLiteral");
  final Cache StringLiteral = new Cache("StringLiteral","StringLiteral");
  final Cache Escape = new Cache("Escape","Escape");
  final Cache OctalEscape = new Cache("OctalEscape","OctalEscape");
  final Cache UnicodeEscape = new Cache("UnicodeEscape","UnicodeEscape");
  final Cache AT = new Cache("AT","AT");
  final Cache AND = new Cache("AND","AND");
  final Cache ANDAND = new Cache("ANDAND","ANDAND");
  final Cache ANDEQU = new Cache("ANDEQU","ANDEQU");
  final Cache BANG = new Cache("BANG","BANG");
  final Cache BSR = new Cache("BSR","BSR");
  final Cache BSREQU = new Cache("BSREQU","BSREQU");
  final Cache COLON = new Cache("COLON","COLON");
  final Cache COMMA = new Cache("COMMA","COMMA");
  final Cache DEC = new Cache("DEC","DEC");
  final Cache DIV = new Cache("DIV","DIV");
  final Cache DIVEQU = new Cache("DIVEQU","DIVEQU");
  final Cache DOT = new Cache("DOT","DOT");
  final Cache ELLIPSIS = new Cache("ELLIPSIS","ELLIPSIS");
  final Cache EQU = new Cache("EQU","EQU");
  final Cache EQUAL = new Cache("EQUAL","EQUAL");
  final Cache GE = new Cache("GE","GE");
  final Cache GT = new Cache("GT","GT");
  final Cache HAT = new Cache("HAT","HAT");
  final Cache HATEQU = new Cache("HATEQU","HATEQU");
  final Cache INC = new Cache("INC","INC");
  final Cache LBRK = new Cache("LBRK","LBRK");
  final Cache LE = new Cache("LE","LE");
  final Cache LPAR = new Cache("LPAR","LPAR");
  final Cache LPOINT = new Cache("LPOINT","LPOINT");
  final Cache LT = new Cache("LT","LT");
  final Cache LWING = new Cache("LWING","LWING");
  final Cache MINUS = new Cache("MINUS","MINUS");
  final Cache MINUSEQU = new Cache("MINUSEQU","MINUSEQU");
  final Cache MOD = new Cache("MOD","MOD");
  final Cache MODEQU = new Cache("MODEQU","MODEQU");
  final Cache NOTEQUAL = new Cache("NOTEQUAL","NOTEQUAL");
  final Cache OR = new Cache("OR","OR");
  final Cache OREQU = new Cache("OREQU","OREQU");
  final Cache OROR = new Cache("OROR","OROR");
  final Cache PLUS = new Cache("PLUS","PLUS");
  final Cache PLUSEQU = new Cache("PLUSEQU","PLUSEQU");
  final Cache QUERY = new Cache("QUERY","QUERY");
  final Cache RBRK = new Cache("RBRK","RBRK");
  final Cache RPAR = new Cache("RPAR","RPAR");
  final Cache RPOINT = new Cache("RPOINT","RPOINT");
  final Cache RWING = new Cache("RWING","RWING");
  final Cache SEMI = new Cache("SEMI","SEMI");
  final Cache SL = new Cache("SL","SL");
  final Cache SLEQU = new Cache("SLEQU","SLEQU");
  final Cache SR = new Cache("SR","SR");
  final Cache SREQU = new Cache("SREQU","SREQU");
  final Cache STAR = new Cache("STAR","STAR");
  final Cache STAREQU = new Cache("STAREQU","STAREQU");
  final Cache TILDA = new Cache("TILDA","TILDA");
  final Cache EOT = new Cache("EOT","EOT");
  
  final Cache ImportDeclaration_0 = new Cache("ImportDeclaration_0"); // IMPORT STATIC? QualifiedIdentifier (DOT STAR)? SEMI
  final Cache ImportDeclaration_1 = new Cache("ImportDeclaration_1"); // DOT STAR
  final Cache TypeDeclaration_0 = new Cache("TypeDeclaration_0"); // Modifier* (ClassDeclaration / EnumDeclaration / InterfaceDeclaration / AnnotationTypeDeclaration)
  final Cache ClassDeclaration_0 = new Cache("ClassDeclaration_0"); // EXTENDS ClassType
  final Cache ClassDeclaration_1 = new Cache("ClassDeclaration_1"); // IMPLEMENTS ClassTypeList
  final Cache ClassBodyDeclaration_0 = new Cache("ClassBodyDeclaration_0"); // STATIC? Block
  final Cache ClassBodyDeclaration_1 = new Cache("ClassBodyDeclaration_1"); // Modifier* MemberDecl
  final Cache MemberDecl_0 = new Cache("MemberDecl_0"); // TypeParameters GenericMethodOrConstructorRest
  final Cache MemberDecl_1 = new Cache("MemberDecl_1"); // Type Identifier MethodDeclaratorRest
  final Cache MemberDecl_2 = new Cache("MemberDecl_2"); // Type VariableDeclarators SEMI
  final Cache MemberDecl_3 = new Cache("MemberDecl_3"); // VOID Identifier VoidMethodDeclaratorRest
  final Cache MemberDecl_4 = new Cache("MemberDecl_4"); // Identifier ConstructorDeclaratorRest
  final Cache GenericMethodOrConstructorRest_0 = new Cache("GenericMethodOrConstructorRest_0"); // (Type / VOID) Identifier MethodDeclaratorRest
  final Cache MethodDeclaratorRest_0 = new Cache("MethodDeclaratorRest_0"); // THROWS ClassTypeList
  final Cache InterfaceDeclaration_0 = new Cache("InterfaceDeclaration_0"); // EXTENDS ClassTypeList
  final Cache InterfaceBodyDeclaration_0 = new Cache("InterfaceBodyDeclaration_0"); // Modifier* InterfaceMemberDecl
  final Cache InterfaceMemberDecl_0 = new Cache("InterfaceMemberDecl_0"); // VOID Identifier VoidInterfaceMethodDeclaratorRest
  final Cache InterfaceMethodOrFieldRest_0 = new Cache("InterfaceMethodOrFieldRest_0"); // ConstantDeclaratorsRest SEMI
  final Cache ConstantDeclaratorsRest_0 = new Cache("ConstantDeclaratorsRest_0"); // COMMA ConstantDeclarator
  final Cache EnumConstants_0 = new Cache("EnumConstants_0"); // COMMA EnumConstant
  final Cache LocalVariableDeclarationStatement_0 = new Cache("LocalVariableDeclarationStatement_0"); // FINAL / Annotation
  final Cache VariableDeclarators_0 = new Cache("VariableDeclarators_0"); // COMMA VariableDeclarator
  final Cache VariableDeclarator_0 = new Cache("VariableDeclarator_0"); // EQU VariableInitializer
  final Cache FormalParameterList_0 = new Cache("FormalParameterList_0"); // FormalParameter (COMMA FormalParameter)* (COMMA LastFormalParameter)?
  final Cache FormalParameterList_1 = new Cache("FormalParameterList_1"); // COMMA FormalParameter
  final Cache FormalParameterList_2 = new Cache("FormalParameterList_2"); // COMMA LastFormalParameter
  final Cache BlockStatement_0 = new Cache("BlockStatement_0"); // Modifier* (ClassDeclaration / EnumDeclaration)
  final Cache Statement_0 = new Cache("Statement_0"); // ASSERT Expression (COLON Expression)? SEMI
  final Cache Statement_1 = new Cache("Statement_1"); // IF ParExpression Statement (ELSE Statement)?
  final Cache Statement_2 = new Cache("Statement_2"); // FOR LPAR ForInit? SEMI Expression? SEMI ForUpdate? RPAR Statement
  final Cache Statement_3 = new Cache("Statement_3"); // FOR LPAR FormalParameter COLON Expression RPAR Statement
  final Cache Statement_4 = new Cache("Statement_4"); // WHILE ParExpression Statement
  final Cache Statement_5 = new Cache("Statement_5"); // DO Statement WHILE ParExpression SEMI
  final Cache Statement_6 = new Cache("Statement_6"); // TRY LPAR Resource (SEMI Resource)* SEMI? RPAR Block Catch* Finally?
  final Cache Statement_7 = new Cache("Statement_7"); // TRY Block (Catch+ Finally? / Finally)
  final Cache Statement_8 = new Cache("Statement_8"); // SWITCH ParExpression LWING SwitchBlockStatementGroups RWING
  final Cache Statement_9 = new Cache("Statement_9"); // SYNCHRONIZED ParExpression Block
  final Cache Statement_10 = new Cache("Statement_10"); // RETURN Expression? SEMI
  final Cache Statement_11 = new Cache("Statement_11"); // THROW Expression SEMI
  final Cache Statement_12 = new Cache("Statement_12"); // BREAK Identifier? SEMI
  final Cache Statement_13 = new Cache("Statement_13"); // CONTINUE Identifier? SEMI
  final Cache Statement_14 = new Cache("Statement_14"); // StatementExpression SEMI
  final Cache Statement_15 = new Cache("Statement_15"); // Identifier COLON Statement
  final Cache Statement_16 = new Cache("Statement_16"); // COLON Expression
  final Cache Statement_17 = new Cache("Statement_17"); // ELSE Statement
  final Cache Statement_18 = new Cache("Statement_18"); // SEMI Resource
  final Cache Statement_19 = new Cache("Statement_19"); // Catch+ Finally?
  final Cache Catch_0 = new Cache("Catch_0"); // OR Type
  final Cache SwitchLabel_0 = new Cache("SwitchLabel_0"); // CASE ConstantExpression COLON
  final Cache SwitchLabel_1 = new Cache("SwitchLabel_1"); // CASE EnumConstantName COLON
  final Cache SwitchLabel_2 = new Cache("SwitchLabel_2"); // DEFAULT COLON
  final Cache ForInit_0 = new Cache("ForInit_0"); // (FINAL / Annotation)* Type VariableDeclarators
  final Cache ForInit_1 = new Cache("ForInit_1"); // StatementExpression (COMMA StatementExpression)*
  final Cache ForInit_2 = new Cache("ForInit_2"); // COMMA StatementExpression
  final Cache Expression_0 = new Cache("Expression_0"); // AssignmentOperator ConditionalExpression
  final Cache ConditionalExpression_0 = new Cache("ConditionalExpression_0"); // QUERY Expression COLON ConditionalOrExpression
  final Cache ConditionalOrExpression_0 = new Cache("ConditionalOrExpression_0"); // OROR ConditionalAndExpression
  final Cache ConditionalAndExpression_0 = new Cache("ConditionalAndExpression_0"); // ANDAND InclusiveOrExpression
  final Cache InclusiveOrExpression_0 = new Cache("InclusiveOrExpression_0"); // OR ExclusiveOrExpression
  final Cache ExclusiveOrExpression_0 = new Cache("ExclusiveOrExpression_0"); // HAT AndExpression
  final Cache AndExpression_0 = new Cache("AndExpression_0"); // AND EqualityExpression
  final Cache EqualityExpression_0 = new Cache("EqualityExpression_0"); // (EQUAL / NOTEQUAL) RelationalExpression
  final Cache RelationalExpression_0 = new Cache("RelationalExpression_0"); // (LE / GE / LT / GT) ShiftExpression / INSTANCEOF ReferenceType
  final Cache RelationalExpression_1 = new Cache("RelationalExpression_1"); // (LE / GE / LT / GT) ShiftExpression
  final Cache RelationalExpression_2 = new Cache("RelationalExpression_2"); // INSTANCEOF ReferenceType
  final Cache ShiftExpression_0 = new Cache("ShiftExpression_0"); // (SL / SR / BSR) AdditiveExpression
  final Cache AdditiveExpression_0 = new Cache("AdditiveExpression_0"); // (PLUS / MINUS) MultiplicativeExpression
  final Cache MultiplicativeExpression_0 = new Cache("MultiplicativeExpression_0"); // (STAR / DIV / MOD) UnaryExpression
  final Cache UnaryExpression_0 = new Cache("UnaryExpression_0"); // PrefixOp UnaryExpression
  final Cache UnaryExpression_1 = new Cache("UnaryExpression_1"); // LPAR Type RPAR UnaryExpression
  final Cache UnaryExpression_2 = new Cache("UnaryExpression_2"); // Primary Selector* PostfixOp*
  final Cache Primary_0 = new Cache("Primary_0"); // NonWildcardTypeArguments (ExplicitGenericInvocationSuffix / THIS Arguments)
  final Cache Primary_1 = new Cache("Primary_1"); // THIS Arguments?
  final Cache Primary_2 = new Cache("Primary_2"); // SUPER SuperSuffix
  final Cache Primary_3 = new Cache("Primary_3"); // NEW Creator
  final Cache Primary_4 = new Cache("Primary_4"); // QualifiedIdentifier IdentifierSuffix?
  final Cache Primary_5 = new Cache("Primary_5"); // BasicType Dim* DOT CLASS
  final Cache Primary_6 = new Cache("Primary_6"); // VOID DOT CLASS
  final Cache Primary_7 = new Cache("Primary_7"); // THIS Arguments
  final Cache IdentifierSuffix_0 = new Cache("IdentifierSuffix_0"); // LBRK (RBRK Dim* DOT CLASS / Expression RBRK)
  final Cache IdentifierSuffix_1 = new Cache("IdentifierSuffix_1"); // DOT (CLASS / ExplicitGenericInvocation / THIS / SUPER Arguments / NEW NonWildcardTypeArguments? InnerCreator)
  final Cache IdentifierSuffix_2 = new Cache("IdentifierSuffix_2"); // RBRK Dim* DOT CLASS
  final Cache IdentifierSuffix_3 = new Cache("IdentifierSuffix_3"); // Expression RBRK
  final Cache IdentifierSuffix_4 = new Cache("IdentifierSuffix_4"); // SUPER Arguments
  final Cache IdentifierSuffix_5 = new Cache("IdentifierSuffix_5"); // NEW NonWildcardTypeArguments? InnerCreator
  final Cache NonWildcardTypeArguments_0 = new Cache("NonWildcardTypeArguments_0"); // COMMA ReferenceType
  final Cache TypeArgumentsOrDiamond_0 = new Cache("TypeArgumentsOrDiamond_0"); // LPOINT RPOINT
  final Cache ExplicitGenericInvocationSuffix_0 = new Cache("ExplicitGenericInvocationSuffix_0"); // Identifier Arguments
  final Cache Selector_0 = new Cache("Selector_0"); // DOT Identifier Arguments?
  final Cache Selector_1 = new Cache("Selector_1"); // DOT ExplicitGenericInvocation
  final Cache Selector_2 = new Cache("Selector_2"); // DOT THIS
  final Cache Selector_3 = new Cache("Selector_3"); // DOT SUPER SuperSuffix
  final Cache Selector_4 = new Cache("Selector_4"); // DOT NEW NonWildcardTypeArguments? InnerCreator
  final Cache SuperSuffix_0 = new Cache("SuperSuffix_0"); // DOT NonWildcardTypeArguments? Identifier Arguments?
  final Cache BasicType_0 = new Cache("BasicType_0","not LetterOrDigit"); // !LetterOrDigit
  final Cache Arguments_0 = new Cache("Arguments_0"); // Expression (COMMA Expression)*
  final Cache Arguments_1 = new Cache("Arguments_1"); // COMMA Expression
  final Cache Creator_0 = new Cache("Creator_0"); // (BasicType / CreatedName) ArrayCreatorRest
  final Cache Creator_1 = new Cache("Creator_1"); // NonWildcardTypeArguments? CreatedName ClassCreatorRest
  final Cache CreatedName_0 = new Cache("CreatedName_0"); // DOT Identifier TypeArgumentsOrDiamond?
  final Cache ArrayCreatorRest_0 = new Cache("ArrayCreatorRest_0"); // Dim+ ArrayInitializer
  final Cache ArrayCreatorRest_1 = new Cache("ArrayCreatorRest_1"); // DimExpr+ Dim*
  final Cache ArrayInitializer_0 = new Cache("ArrayInitializer_0"); // VariableInitializer (COMMA VariableInitializer)*
  final Cache ArrayInitializer_1 = new Cache("ArrayInitializer_1"); // COMMA VariableInitializer
  final Cache QualifiedIdentifier_0 = new Cache("QualifiedIdentifier_0"); // DOT Identifier
  final Cache ReferenceType_0 = new Cache("ReferenceType_0"); // BasicType Dim+
  final Cache ReferenceType_1 = new Cache("ReferenceType_1"); // ClassType Dim*
  final Cache ClassType_0 = new Cache("ClassType_0"); // DOT Identifier TypeArguments?
  final Cache ClassTypeList_0 = new Cache("ClassTypeList_0"); // COMMA ClassType
  final Cache TypeArguments_0 = new Cache("TypeArguments_0"); // COMMA TypeArgument
  final Cache TypeArgument_0 = new Cache("TypeArgument_0"); // QUERY ((EXTENDS / SUPER) ReferenceType)?
  final Cache TypeArgument_1 = new Cache("TypeArgument_1"); // (EXTENDS / SUPER) ReferenceType
  final Cache TypeParameters_0 = new Cache("TypeParameters_0"); // COMMA TypeParameter
  final Cache TypeParameter_0 = new Cache("TypeParameter_0"); // EXTENDS Bound
  final Cache Bound_0 = new Cache("Bound_0"); // AND ClassType
  final Cache Modifier_0 = new Cache("Modifier_0"); // ("public" / "protected" / "private" / "static" / "abstract" / "final" / "native" / "synchronized" / "transient" / "volatile" / "strictfp") !LetterOrDigit Spacing
  final Cache AnnotationTypeElementDeclaration_0 = new Cache("AnnotationTypeElementDeclaration_0"); // Modifier* AnnotationTypeElementRest
  final Cache AnnotationTypeElementRest_0 = new Cache("AnnotationTypeElementRest_0"); // Type AnnotationMethodOrConstantRest SEMI
  final Cache ElementValuePairs_0 = new Cache("ElementValuePairs_0"); // COMMA ElementValuePair
  final Cache ElementValues_0 = new Cache("ElementValues_0"); // COMMA ElementValue
  final Cache Spacing_0 = new Cache("Spacing_0"); // [ \t\r\n\f]+ / "/*" (!"*/" _)* "*/" / "//" (![\r\n] _)* [\r\n]
  final Cache Spacing_1 = new Cache("Spacing_1"); // [ \t\r\n\f]+
  final Cache Spacing_2 = new Cache("Spacing_2"); // "/*" (!"*/" _)* "*/"
  final Cache Spacing_3 = new Cache("Spacing_3"); // "//" (![\r\n] _)* [\r\n]
  final Cache Spacing_4 = new Cache("Spacing_4"); // !"*/" _
  final Cache Spacing_5 = new Cache("Spacing_5"); // ![\r\n] _
  final Cache Identifier_0 = new Cache("Identifier_0","not Keyword"); // !Keyword
  final Cache Literal_0 = new Cache("Literal_0"); // "true" !LetterOrDigit
  final Cache Literal_1 = new Cache("Literal_1"); // "false" !LetterOrDigit
  final Cache Literal_2 = new Cache("Literal_2"); // "null" !LetterOrDigit
  final Cache DecimalNumeral_0 = new Cache("DecimalNumeral_0"); // [1-9] ([_]* [0-9])*
  final Cache DecimalNumeral_1 = new Cache("DecimalNumeral_1"); // [_]* [0-9]
  final Cache BinaryNumeral_0 = new Cache("BinaryNumeral_0"); // [_]* [01]
  final Cache OctalNumeral_0 = new Cache("OctalNumeral_0"); // [_]* [0-7]
  final Cache DecimalFloat_0 = new Cache("DecimalFloat_0"); // Digits "." Digits? Exponent? [fFdD]?
  final Cache DecimalFloat_1 = new Cache("DecimalFloat_1"); // "." Digits Exponent? [fFdD]?
  final Cache DecimalFloat_2 = new Cache("DecimalFloat_2"); // Digits Exponent [fFdD]?
  final Cache DecimalFloat_3 = new Cache("DecimalFloat_3"); // Digits Exponent? [fFdD]
  final Cache HexSignificand_0 = new Cache("HexSignificand_0"); // ("0x" / "0X") HexDigits? "." HexDigits
  final Cache HexSignificand_1 = new Cache("HexSignificand_1"); // HexNumeral "."?
  final Cache HexDigits_0 = new Cache("HexDigits_0"); // [_]* HexDigit
  final Cache CharLiteral_0 = new Cache("CharLiteral_0"); // !['\\n\r] _
  final Cache StringLiteral_0 = new Cache("StringLiteral_0"); // Escape / !["\\n\r] _
  final Cache StringLiteral_1 = new Cache("StringLiteral_1"); // !["\\n\r] _
  final Cache OctalEscape_0 = new Cache("OctalEscape_0"); // [0-3] [0-7] [0-7]
  final Cache OctalEscape_1 = new Cache("OctalEscape_1"); // [0-7] [0-7]
  
  //-------------------------------------------------------------------
  //  List of Cache objects
  //-------------------------------------------------------------------
  
  Cache[] cacheList =
  {
    CompilationUnit,PackageDeclaration,ImportDeclaration,
    TypeDeclaration,ClassDeclaration,ClassBody,ClassBodyDeclaration,
    MemberDecl,GenericMethodOrConstructorRest,MethodDeclaratorRest,
    VoidMethodDeclaratorRest,ConstructorDeclaratorRest,MethodBody,
    InterfaceDeclaration,InterfaceBody,InterfaceBodyDeclaration,
    InterfaceMemberDecl,InterfaceMethodOrFieldDecl,
    InterfaceMethodOrFieldRest,InterfaceMethodDeclaratorRest,
    InterfaceGenericMethodDecl,VoidInterfaceMethodDeclaratorRest,
    ConstantDeclaratorsRest,ConstantDeclarator,ConstantDeclaratorRest,
    EnumDeclaration,EnumBody,EnumConstants,EnumConstant,
    EnumBodyDeclarations,LocalVariableDeclarationStatement,
    VariableDeclarators,VariableDeclarator,FormalParameters,
    FormalParameter,LastFormalParameter,FormalParameterList,
    VariableDeclaratorId,Block,BlockStatements,BlockStatement,
    Statement,Resource,Catch,Finally,SwitchBlockStatementGroups,
    SwitchBlockStatementGroup,SwitchLabel,ForInit,ForUpdate,
    EnumConstantName,StatementExpression,ConstantExpression,
    Expression,AssignmentOperator,ConditionalExpression,
    ConditionalOrExpression,ConditionalAndExpression,
    InclusiveOrExpression,ExclusiveOrExpression,AndExpression,
    EqualityExpression,RelationalExpression,ShiftExpression,
    AdditiveExpression,MultiplicativeExpression,UnaryExpression,
    Primary,IdentifierSuffix,ExplicitGenericInvocation,
    NonWildcardTypeArguments,TypeArgumentsOrDiamond,
    NonWildcardTypeArgumentsOrDiamond,ExplicitGenericInvocationSuffix,
    PrefixOp,PostfixOp,Selector,SuperSuffix,BasicType,Arguments,
    Creator,CreatedName,InnerCreator,ClassCreatorRest,
    ArrayCreatorRest,ArrayInitializer,VariableInitializer,
    ParExpression,QualifiedIdentifier,Dim,DimExpr,Type,ReferenceType,
    ClassType,ClassTypeList,TypeArguments,TypeArgument,TypeParameters,
    TypeParameter,Bound,Modifier,AnnotationTypeDeclaration,
    AnnotationTypeBody,AnnotationTypeElementDeclaration,
    AnnotationTypeElementRest,AnnotationMethodOrConstantRest,
    AnnotationMethodRest,AnnotationConstantRest,DefaultValue,
    Annotation,NormalAnnotation,SingleElementAnnotation,
    MarkerAnnotation,ElementValuePairs,ElementValuePair,ElementValue,
    ElementValueArrayInitializer,ElementValues,Spacing,Identifier,
    Letter,LetterOrDigit,Keyword,ASSERT,BREAK,CASE,CATCH,CLASS,
    CONTINUE,DEFAULT,DO,ELSE,ENUM,EXTENDS,FINALLY,FINAL,FOR,IF,
    IMPLEMENTS,IMPORT,INTERFACE,INSTANCEOF,NEW,PACKAGE,RETURN,STATIC,
    SUPER,SWITCH,SYNCHRONIZED,THIS,THROWS,THROW,TRY,VOID,WHILE,
    Literal,IntegerLiteral,DecimalNumeral,HexNumeral,BinaryNumeral,
    OctalNumeral,FloatLiteral,DecimalFloat,Exponent,HexFloat,
    HexSignificand,BinaryExponent,Digits,HexDigits,HexDigit,
    CharLiteral,StringLiteral,Escape,OctalEscape,UnicodeEscape,AT,AND,
    ANDAND,ANDEQU,BANG,BSR,BSREQU,COLON,COMMA,DEC,DIV,DIVEQU,DOT,
    ELLIPSIS,EQU,EQUAL,GE,GT,HAT,HATEQU,INC,LBRK,LE,LPAR,LPOINT,LT,
    LWING,MINUS,MINUSEQU,MOD,MODEQU,NOTEQUAL,OR,OREQU,OROR,PLUS,
    PLUSEQU,QUERY,RBRK,RPAR,RPOINT,RWING,SEMI,SL,SLEQU,SR,SREQU,STAR,
    STAREQU,TILDA,EOT,ImportDeclaration_0,ImportDeclaration_1,
    TypeDeclaration_0,ClassDeclaration_0,ClassDeclaration_1,
    ClassBodyDeclaration_0,ClassBodyDeclaration_1,MemberDecl_0,
    MemberDecl_1,MemberDecl_2,MemberDecl_3,MemberDecl_4,
    GenericMethodOrConstructorRest_0,MethodDeclaratorRest_0,
    InterfaceDeclaration_0,InterfaceBodyDeclaration_0,
    InterfaceMemberDecl_0,InterfaceMethodOrFieldRest_0,
    ConstantDeclaratorsRest_0,EnumConstants_0,
    LocalVariableDeclarationStatement_0,VariableDeclarators_0,
    VariableDeclarator_0,FormalParameterList_0,FormalParameterList_1,
    FormalParameterList_2,BlockStatement_0,Statement_0,Statement_1,
    Statement_2,Statement_3,Statement_4,Statement_5,Statement_6,
    Statement_7,Statement_8,Statement_9,Statement_10,Statement_11,
    Statement_12,Statement_13,Statement_14,Statement_15,Statement_16,
    Statement_17,Statement_18,Statement_19,Catch_0,SwitchLabel_0,
    SwitchLabel_1,SwitchLabel_2,ForInit_0,ForInit_1,ForInit_2,
    Expression_0,ConditionalExpression_0,ConditionalOrExpression_0,
    ConditionalAndExpression_0,InclusiveOrExpression_0,
    ExclusiveOrExpression_0,AndExpression_0,EqualityExpression_0,
    RelationalExpression_0,RelationalExpression_1,
    RelationalExpression_2,ShiftExpression_0,AdditiveExpression_0,
    MultiplicativeExpression_0,UnaryExpression_0,UnaryExpression_1,
    UnaryExpression_2,Primary_0,Primary_1,Primary_2,Primary_3,
    Primary_4,Primary_5,Primary_6,Primary_7,IdentifierSuffix_0,
    IdentifierSuffix_1,IdentifierSuffix_2,IdentifierSuffix_3,
    IdentifierSuffix_4,IdentifierSuffix_5,NonWildcardTypeArguments_0,
    TypeArgumentsOrDiamond_0,ExplicitGenericInvocationSuffix_0,
    Selector_0,Selector_1,Selector_2,Selector_3,Selector_4,
    SuperSuffix_0,BasicType_0,Arguments_0,Arguments_1,Creator_0,
    Creator_1,CreatedName_0,ArrayCreatorRest_0,ArrayCreatorRest_1,
    ArrayInitializer_0,ArrayInitializer_1,QualifiedIdentifier_0,
    ReferenceType_0,ReferenceType_1,ClassType_0,ClassTypeList_0,
    TypeArguments_0,TypeArgument_0,TypeArgument_1,TypeParameters_0,
    TypeParameter_0,Bound_0,Modifier_0,
    AnnotationTypeElementDeclaration_0,AnnotationTypeElementRest_0,
    ElementValuePairs_0,ElementValues_0,Spacing_0,Spacing_1,Spacing_2,
    Spacing_3,Spacing_4,Spacing_5,Identifier_0,Literal_0,Literal_1,
    Literal_2,DecimalNumeral_0,DecimalNumeral_1,BinaryNumeral_0,
    OctalNumeral_0,DecimalFloat_0,DecimalFloat_1,DecimalFloat_2,
    DecimalFloat_3,HexSignificand_0,HexSignificand_1,HexDigits_0,
    CharLiteral_0,StringLiteral_0,StringLiteral_1,OctalEscape_0,
    OctalEscape_1
  };
}
